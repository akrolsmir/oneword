<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>Kingdom Royale</title>
  <link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html {
      margin: 0;
      height: 100%;
      background-color: #efd8fa;
      position: relative;
      overflow: auto;
    }

    h1,
    h2,
    h3 {
      font-family: 'Merienda One', cursive;
    }

    body {
      margin: 48px auto;
      width: 600px;
      max-width: 95vw;
    }

    .pre-wrap {
      white-space: pre-wrap;
    }
  </style>

  <meta name="description" content="Conspire and backstab your friends in this cutthroat kingdom!" />

  <!-- Octopus favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f419.png" />
</head>

<body class="has-navbar-fixed-top">
  <div id="vue">
    <!-- <div v-for="enemies, role in WIN_CONDITIONS">{{ role }} -- {{ enemies }}</div> -->
    <!-- Main chat area -->
    <div>
      Name:
      <input class="input" v-model="player.name" />
      <button class="button" @click="enterGame">Enter game</button>

      <div v-if="room.state === 'NOT_STARTED'"></div>
      <div v-else>
        {{ player.name }}, you are the {{ playerRole }}.<br />
        <span class="pre-wrap">{{ FLAVOR[playerRole] }}</span>
      </div>

      <button class="button" @click="assignRoles">Assign Roles</button>

      <h3>Players</h3>
      <span class="tag m-1" v-for="name in Object.keys(room.players)">{{ name }}</span>

      <h3>First Chat</h3>
      <br /><br />

      <chatbox
        :name="player.name"
        :room-id="room.name"
        v-model="room.round.main1.chatlog"
        chatlog-path="round.main1.chatlog"
      ></chatbox>

      <!-- Pick your secret partner -->
      <h3>Pick your secret partner</h3>
      <div class="select">
        <select v-model="player.target">
          <option v-for="player, name in room.players" :value="name">{{ name }}</option>
        </select>
      </div>
      <button class="button" @click="pickPartner(player.target)">Pick</button>

      <!-- List partners for now -->
      <h3>Not-so-secret partners</h3>
      <div v-for="value, player in room.round.secret">{{ player }} picked {{ value.target }}</div>
    </div>

    <!-- 1:1 chat -->
    <h3>Second Chat</h3>
    <!-- Goes here -->
    <br /><br />

    <!-- Mod tools -->
    <div class="box">
      <h3>Mod tools</h3>
      <button class="button is-small is-danger" @click="resetRoom">Reset room</button>
    </div>
  </div>
</body>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<script type="module" src="components/chatbox.js"></script>

<script>
  window.COLLECTION = 'kingdom-royale';
</script>
<script type="module">
  import { listenRoom, updateRoom, setRoom, getRoom } from './firebase-network.js';
  /**
     Room: {
        name: apple,
        players: {
          alice : {
            role: 'KING'
            dead: true
          }
        },
        round: {
          state: MAIN1', // or 'NOT_STARTED', 'SECRET1', 'SECRET2'..., 'MAIN2', 'NIGHT'
          main1: { // 120s
            chatlog: {
              // ID is timestamp, for now.
              // TODO: Will there be collisions? Could hash timestamp + name
              // TODO: Is it too expensive to sort? Probably not?
              123456: { player: 'alice', text: 'Hello World'}
            }
          },
          secret: { // 60s each, parallelized
            alice: {
              partner: 'bob',
              chatlog: {...}
            }
            bob: {
              partner: 'carol',
              chatlog: {...}
            }
          }
          main2: { // 120s
            murder: {
              target: 'bob',
              approved: 'SORCERER',
            }
            chatlog: {...}
          }
          night: { // 60s
            assassination: {
              target: 'alice',
              // flavor: 'A ambitious caption fired Alice, and they died'????
            }
          }
        }
        history: [{round1}, ...]
     }
    */
  const WIN_CONDITIONS = {
    KING: ['PRINCE', 'REVOLUTIONARY'],
    PRINCE: ['KING', 'DOUBLE', 'REVOLUTIONARY'],
    DOUBLE: ['PRINCE', 'REVOLUTIONARY'],
    SORCERER: [''],
    KNIGHT: ['KING', 'PRINCE'],
    REVOLUTIONARY: ['KING', 'PRINCE', 'DOUBLE'],
  };

  const ROLES = Object.keys(WIN_CONDITIONS);

  const FLAVOR = {
    KING: `He is the king who has ascended to the throne by assassinating the previous ruler and has carried out many invasions. Having a distrustful personality, he's scheming murder of the ones that threaten his throne.

Skills

[Murder]. He can select a player he wants to kill another player to Sorcerer and or the Knight to execute this action, using [Sorcery] or [Deathblow].

Victory conditions: To protect his throne, death of the Prince and Revolutionary.`,
    PRINCE: `An ambitious person. He was originally only at the third place in the inheritance order of the king's rank. But taking advantage of the king's mistrust, he made him murder other princes and moved up to the first place.

Skills

[Throne succession]. He is able to use Murder once the King and The Double die.
[Anti-magic]. He can't be killed by Sorcery.

Victory conditions: To become the king, death of King, The Double, and Revolutionary.`,
    DOUBLE: `An ex-farmer who is loyal to the king and looks exactly the same as him. He is not really ambitious.

Skills

[Inheritance]. If the King dies or [Substitution] was executed, he is able to use [Murder].

Victory conditions: Death of those who try to kill him, Prince and Revolutionary.`,
    SORCERER: `King's subordinate and Prince's teacher. He has no interest in the king's throne whatsoever.

Skills

[Sorcery]. He can choose whether to kill the character that was selected by [Murder]. The targeted character will become a burnt corpse.

Victory conditions: To survive.`,
    KNIGHT: `King's subordinate, but he is plotting a revenge on the royal family for they have ruined his homeland.

Skills

[Deathblow]. He can choose whether to kill the character that was selected by [Murder]. The targeted character will die due to beheading. Only executable when the Sorcerer is dead.

Victory conditions: To take revenge, death of King and Prince.`,
    REVOLUTIONARY: `The right arm of the king and prepares himself to take over the land.

Skills

[Assassination]. He can assassinate the selected character. The targeted character will become a strangulated corpse.

Victory conditions: Death of the King, the Prince, and the Double`,
  };

  const vueApp = new Vue({
    el: '#vue',
    data: {
      WIN_CONDITIONS,
      ROLES,
      FLAVOR,
      player: {
        name: 'Austin',
        chat: '',
        target: '',
      },
      room: {
        name: 'apple',
      },
    },
    async mounted() {
      const room = await getRoom(this.room);
      if (room) {
        this.room = room;
      } else {
        await resetRoom();
      }
    },
    methods: {
      async resetRoom() {
        this.room = {
          name: 'apple',
          players: {
            // Alice: { role: '' },
            Bob: { role: '' },
            Carol: { role: '' },
            David: { role: '' },
            Eve: { role: '' },
            Frank: { role: '' },
          },
          round: {
            state: 'MAIN1',
            main1: {
              chatlog: {
                123456: {
                  name: 'Alice',
                  text: 'Bob is the imposter!',
                  timestamp: 123456,
                },
                234567: {
                  name: 'Bob',
                  text: "No, I swear it's Carol...",
                  timestamp: 234567,
                },
              },
            },
            secret: {},
          },
        };
        await setRoom(this.room);
      },
      async enterGame() {
        await updateRoom(this.room, { [`players.${this.player.name}`]: {} });
      },
      async assignRoles() {
        if (Object.keys(this.room.players).length != 6) {
          alert('Wrong number of players; need exactly 6!');
          return;
        }

        const roles = ROLES.slice();
        shuffleArray(roles);
        for (let i = 0; i < 6; i++) {
          const name = this.playerNames[i];
          this.room.players[name].role = roles[i];
        }
        await updateRoom(this.room, { players: this.room.players });
      },
      async pickPartner(target) {
        await updateRoom(this.room, {
          [`round.secret.${this.player.name}.target`]: target,
        });
      },
    },
    computed: {
      playerNames() {
        return Object.keys(this.room.players);
      },
      playerRole() {
        try {
          return this.room.players[this.player.name].role;
        } catch (error) {
          return 'KING';
        }
      },
    },
  });
  listenRoom(vueApp);

  // Returns a list of blocks, eg [{alice: {partner: 'bob'}, ...}, {carol: {partner: 'alice'}} ]
  function sequenceChats(secret) {
    // Naive implementation: serial
    return Object.entries(secret).map(([player, secret]) => {
      return { [player]: secret };
    });

    // 1. find the first person and give them their partner
    // const remaining = Object.keys(secret);
  }

  function shuffleArray(array) {
    // From https://stackoverflow.com/a/12646864/1222351
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
</script>
