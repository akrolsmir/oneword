<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>One Word</title>
  <link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css" />
  <style>
    html {
      margin: 0;
      height: 100%;
      background-color: #aeecef;
      position: relative;
      overflow: auto;
    }

    h1,
    h2,
    h3 {
      font-family: 'Merienda One', cursive;
    }

    body {
      margin: 48px;
      width: 600px;
    }

    .card {
      padding: 8px;
      margin-bottom: 8px;
    }
  </style>
  <meta name="description" content="Play the word game Contact, online!" />

  <!-- Dolphin favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f42c.png" />
</head>

<body>
  <div id="vue">
    Player Name: <input v-model="player.name" /> <br />
    Room Name: <input v-model="room.name" /> <br />
    <button @click="resetRoom">Reset room</button>
    <button @click="enterRoom">Enter room</button>
    <button @click="nextRound">Next round</button>
    <br /><br />
    <div v-if="room && room.currentRound">
      <!-- Room header -->
      <article class="message">
        <div class="message-header">
          <h1>{{ room.name }}</h1>
          <h2 class="capitalize">Round ???</h2>
        </div>
        <div class="message-body">
          Players: {{ room.players.join(', ') }} <br />
          Wordmaster: {{ room.currentRound.wordmaster }}
        </div>
      </article>

      <!-- Word -->
      <h3>Word</h3>
      <div v-if="room.currentRound.word">
        <h2 class="title has-text-centered is-size-1">{{ prefix.toUpperCase() }}...?</h2>
      </div>
      <div v-else-if="player.name == room.currentRound.wordmaster">
        <input class="input" v-model="player.word" @keyup.enter="chooseWord" />
        <button class="button" @click="chooseWord">Choose!</button>
      </div>
      <br /><br />

      <div class="columns">
        <!-- Clues -->
        <div class="column">
          <h3>Clues</h3>
          <div v-if="!clueGiven">
            <div class="card">
              <h3>Add a clue!</h3>
              <input class="input" v-model="player.hint" placeholder="Hint" />
              <Submit
                placeholder="Word"
                button-text="Create"
                :on-submit="createClue"
                :invalid="(word) => room.currentRound.banned.includes(word) || !word.startsWith(prefix)"
              />
            </div>
          </div>
          <template v-for="(clue, cluer) in room.currentRound.clues">
            <div class="card">
              <h3>{{ cluer }}'s clue: {{ clue.hint }}</h3>
              <template v-if="clue.contact">
                Contacted {{clue.contact}}!
                <!-- Need to debug this... -->
                <timer :length="10" :on-finish="onContact(cluer, clue)"></timer>
                <button v-if="player.name == room.currentRound.wordmaster" @click="onContact(cluer, clue)()">
                  Resolve
                </button>
              </template>
              <template v-else-if="cluer === player.name">
                {{ clue.word }}
                <button @click="withdrawClue">Withdraw</button>
              </template>
              <template v-else-if="player.name !== room.currentRound.wordmaster">
                <Submit
                  placeholder="Word"
                  button-text="Contact!"
                  :on-submit="contact(cluer)"
                  :invalid="(word) => room.currentRound.banned.includes(word) || !word.startsWith(prefix)"
                />
              </template>
            </div>
          </template>
        </div>

        <!-- Banned -->
        <div class="column">
          <h3>Banned</h3>
          <div class="card">
            <div v-if="player.name == room.currentRound.wordmaster">
              <Submit
                placeholder="Word"
                button-text="Ban!"
                :on-submit="banWord"
                :invalid="(word) => room.currentRound.banned.includes(word) || !word.startsWith(prefix)"
              />
            </div>
            <ul v-for="word in room.currentRound.banned">
              <li>{{ word }}</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert@2.1.2/dist/sweetalert.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.13.0/js/md5.min.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<!-- My code -->
<script>
  window.COLLECTION = 'contact';
</script>
<script type="module" src="./firebase-network.js"></script>
<script type="module" src="components/navbar.js"></script>
<script type="module" src="components/timer.js"></script>
<script type="module" src="components/scoreboard.js"></script>
<script type="module" src="components/submit.js"></script>
<script type="module">
  import {
    setRoom,
    updateRoom,
    getRoom,
    listRooms,
    listenRoom,
    unlistenRoom,
    listenForLogin,
  } from './firebase-network.js';

  /**
    Room: {
      name: 'apple',
      players: ['alice', 'bob', 'carol'],
      currentRound: {
        revealed: 2,
        wordmaster: 'alice',
        word: 'company'
        banned: ['cloak', 'collar', 'condone'],
        clues: {
          bob: {
            hint: 'square',
            word: 'corner',
            contact: 'carol',
            contactedWord: 'corner',
          },
          carol: ...
        }
      }
      history: [{round1}, ...]
    }
    */
  const vueApp = new Vue({
    el: '#vue',
    data: {
      user: {},
      allRooms: [],
      room: {
        name: 'default-room',
        history: [],
      },
      player: {
        name: '',
        // Cluing but not yet set to firebase
        hint: '',
        word: '',
        toBan: '',
      },
    },
    async mounted() {
      // Detect url params like ?room=party&player=austin
      const parsedUrl = new URL(window.location.href);
      const roomName = parsedUrl.searchParams.get('room');
      const playerName = parsedUrl.searchParams.get('player');
      if (playerName) {
        this.player.name = playerName;
      }
      if (roomName) {
        this.room.name = roomName;
        await this.enterRoom();
      }
    },
    methods: {
      async enterRoom() {
        if (!this.player.name) {
          this.$refs.navbar.logIn();
          return;
        }
        const room = await getRoom(this.room);
        if (room) {
          this.room = room;
          return await this.joinRoom();
        } else {
          // Create a new room
          listenRoom(this);
          return await this.resetRoom();
        }
      },
      async resetRoom() {
        this.room = {
          name: this.room.name,
          players: [],
          currentRound: {
            revealed: 1,
            wordmaster: this.player.name,
            word: '',
            banned: [],
            clues: {},
          },
          history: [],
        };
        await setRoom(this.room);
      },
      // Only call if room already exists.
      async joinRoom() {
        listenRoom(this);

        if (!this.room.players.includes(this.player.name)) {
          this.room.players.push(this.player.name);
          await updateRoom(this.room, { players: this.room.players });
        }
      },
      async createClue(word) {
        if (word == this.room.currentRound.word) {
          swal('Victory!', `${this.player.name} correctly guessed the word "${this.room.currentRound.word}"`);
          await this.nextRound();
        } else {
          const update = {
            [`currentRound.clues.${this.player.name}`]: {
              word,
              hint: this.player.hint,
              contact: '',
              contactedWord: '',
            },
          };
          await updateRoom(this.room, update);
        }
      },
      async withdrawClue() {
        delete this.room.currentRound.clues[this.player.name];
        await updateRoom(this.room, {
          'currentRound.clues': this.room.currentRound.clues,
        });
      },
      async nextLetter() {
        this.room.currentRound.revealed++;
        if (this.room.currentRound.revealed >= this.room.currentRound.word.length) {
          swal('Victory', `The word is "${this.room.currentRound.word}"`);
          await this.nextRound();
        } else {
          this.room.currentRound.clues = {};
          await updateRoom(this.room, { currentRound: this.room.currentRound });
        }
      },
      // Wrapper, since Submit onEnter expects a function.
      contact(cluer) {
        return async (word) => {
          const update = {
            [`currentRound.clues.${cluer}.contact`]: this.player.name,
            [`currentRound.clues.${cluer}.contactedWord`]: word,
          };
          await updateRoom(this.room, update);
        };
      },
      // Wrapper, since timer onFinish expects a function.
      onContact(cluer, clue) {
        return async () => {
          // Show everyone the "Contact message"
          const matched = clue.word === clue.contactedWord;
          const message = `${matched ? '' : 'NO '} CONTACT!\n${cluer}: ${clue.word}\n${clue.contact}: ${
            clue.contactedWord
          }`;
          swal(message);

          if (this.player.name !== this.room.currentRound.wordmaster) {
            return;
          }

          if (matched) {
            this.room.currentRound.banned.push(clue.word);
            this.room.currentRound.revealed++;
            delete this.room.currentRound.clues;
            this.room.currentRound.clues = {};
          } else {
            // Ban both words and reset
            this.room.currentRound.banned.push(clue.word);
            this.room.currentRound.banned.push(clue.contactedWord);
            delete this.room.currentRound.clues[cluer];
          }
          await updateRoom(this.room, {
            currentRound: this.room.currentRound,
          });
        };
      },
      async banWord(toBan) {
        if (this.room.currentRound.banned.includes(toBan)) {
          return; // Word is already banned.
        }

        this.room.currentRound.banned.push(toBan);
        for (const [cluer, clue] of Object.entries(this.room.currentRound.clues)) {
          if (clue.word === toBan) {
            // Remove the clue entirely
            delete this.room.currentRound.clues[cluer];
          } else if (clue.contactedWord === toBan) {
            // Remove the contacted information, but NOT the original clue.
            clue.contact = '';
            clue.contactedWord = '';
          }
        }
        await updateRoom(this.room, {
          currentRound: this.room.currentRound,
        });
      },
      async chooseWord() {
        await updateRoom(this.room, {
          'currentRound.word': this.player.word,
        });
      },
      async nextRound() {
        const newRound = {
          revealed: 1,
          wordmaster: this.player.name,
          word: '',
          banned: [],
          clues: {},
        };
        await updateRoom(this.room, {
          currentRound: newRound,
          history: [...this.room.history, this.room.currentRound],
        });
      },
    },
    computed: {
      clueGiven() {
        return (
          this.room.currentRound.wordmaster === this.player.name ||
          Object.keys(this.room.currentRound.clues).includes(this.player.name)
        );
      },
      prefix() {
        return this.room.currentRound.word.slice(0, this.room.currentRound.revealed);
      },
    },
  });
</script>
