<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>Incrypt</title>
  <link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html {
      margin: 0;
      height: 100%;
      /* Maybe palette: https://coolors.co/acad94-db162f-d8d4d5-5f758e-383961 */
      background-color: #d8d4d5;
      position: relative;
      overflow: auto;
    }

    h1,
    h2,
    h3 {
      font-family: 'Merienda One', cursive;
    }

    h1 {
      font-size: 40px;
    }

    h2 {
      margin-top: 16px;
      font-size: 24px;
    }

    body {
      margin: 48px auto;
      width: 600px;
      max-width: 95vw;
    }

    [v-cloak] {
      display: none;
    }
  </style>

  <!-- Shark favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f988.png" />
</head>

<body class="has-navbar-fixed-top">
  <h1>Welcome to Incrypt</h1>
  <div id="vue">
    <button class="button is-small is-danger" @click="resetRoom">Reset game</button>
    <h2>Your name <input class="input" v-model="player.name" /></h2>
    <h2>Room: {{ room.name }}</h2>
    <template v-for="team in ['redTeam', 'blueTeam']">
      <h3>
        {{ room[team].name }} team: {{ room[team].players.join(', ') }}
        <a v-if="!room[team].players.includes(player.name)" @click="joinTeam(team)">(join)</a>
      </h3>
      Interceptions: {{ room[team].intercepted }}<br />
      Dropped messages: {{ room[team].dropped }}<br />
    </template>
    <br /><br />
    <!-- In game -->
    <div v-if="room.currentRound.state === 'NOT_STARTED'" class="box">
      <div v-if="room.redTeam.players.length < 2 ">
        {{ room.redTeam.name }} team needs {{ 2 - room.redTeam.players.length }} more, before we can start!
      </div>
      <div v-else-if="room.blueTeam.players.length < 2 ">
        {{ room.blueTeam.name }} team needs {{ 2 - room.blueTeam.players.length }} more, before we can start!
      </div>
      <div v-else>
        Awesome! There are {{ room.redTeam.players.length }} players on {{ room.redTeam.name }} and {{
        room.blueTeam.players.length }} players on {{ room.blueTeam.name }}.
        <br /><br />
        Ready to start?
        <br />
        <button class="button" @click="newRound(/*saveCurrentRound=*/false)">Start game!</button>
      </div>
    </div>
    <div v-cloak v-if="room.currentRound.state === 'ENCODING'" class="box">
      <h2>{{ myTeam.name }} words</h2>
      <h3>{{ myTeam.words.join(' / ') }}</h3>
      <br /><br />
      <div v-if="player.name === myTeamRound.spy">
        <h3>You are the {{ myTeam.name }} spy! Encode for your team: {{ myTeamRound.key.join(' - ') }}</h3>
        <div v-for="(digit, i) in myTeamRound.key">
          {{ digit }} - {{ myTeam.words[digit - 1] }}
          <input class="input" v-model="player.encode[i]" />
        </div>
        <button class="button" @click="submitEncode()">Encode</button>
      </div>
      <div v-else>
        <h3>Waiting for {{ myTeamRound.spy }} to encode the key...</h3>
      </div>
    </div>
    <!-- Red team's turn to guess Blue team's code -->
    <div v-if="room.currentRound.state === 'RED_INTERCEPT'" class="box">
      <div v-if="isRed">
        <!-- Section: Show the blue spy's code -->
        <h3>The blue spy encoded: "{{ room.currentRound.blueTeam.encode.join(' - ') }}". Try intercepting it:</h3>
        <br />
        <!-- Section: Vote for the code -->
        <template v-for="(encoded, e) in room.currentRound.blueTeam.encode">
          <div class="select">
            <select v-model="player.intercept[e]">
              <option v-for="(word, i) in room.blueTeam.words" :value="i + 1">Word {{ i + 1 }}</option>
            </select>
          </div>
          -
        </template>
        <button class="button" @click="submitIntercept()">Submit</button>
        <br /><br />
        <!-- Section: See all past clues -->
        <div v-for="(word, i) in room.blueTeam.words">
          Word {{ i + 1 }}
          <div v-for="(round, r) in room.history">
            <div v-if="round.blueTeam.key.includes(i + 1 )">
              --- Round {{ r }}: {{ round.blueTeam.encode[round.blueTeam.key.indexOf(i + 1)] }}
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Both teams try to decode the key -->
    <div v-if="room.currentRound.state === 'DECODING'">
      <div v-if="player.name === myTeamRound.spy">Waiting for your teammantes to decode your message...</div>
      <div v-else class="box">
        <h3>Decode what {{ myTeamRound.spy }} meant by "{{ myTeamRound.encode.join(' - ') }}":</h3>
        <!-- (TODO: deduplicate or component-ize with above) -->
        <!-- Section: Vote for the code -->
        <template v-for="(encoded, e) in myTeamRound.encode">
          <div class="select">
            <select v-model="player.decode[e]">
              <option v-for="(word, i) in myTeam.words" :value="i + 1">Word {{ i + 1 }}</option>
            </select>
          </div>
          -
        </template>
        <button class="button" @click="submitDecode(myTeamId)">Submit</button>
        <br /><br />
        <!-- Section: See your words-->
        <h2>{{ myTeam.name }} words</h2>
        <h3>{{ myTeam.words.join(' / ') }}</h3>
      </div>
    </div>
    <!-- Results for both teams! -->
    <div v-if="room.currentRound.state === 'DONE'" class="box">
      <template v-for="team in ['redTeam', 'blueTeam']">
        <h3>{{ room[team].name }} team's message was "{{ room.currentRound[team].key.join(' - ') }}"</h3>
        <div v-if="keysEqual(room.currentRound[other(team)].intercept, room.currentRound[team].key)">
          {{ room[other(team)].name }} team intercepted {{ room[team].name }} team's message ðŸ˜®
        </div>
        <div v-else-if="keysEqual(room.currentRound[team].decode, room.currentRound[team].key)">
          {{ room[team].name }} team succesfully decoded their message. Nice job!
        </div>
        <div v-else>
          {{ room[team].name }} team thought it was "{{ room.currentRound[team].decode.join(' - ') }}". Sorry, {{
          room.currentRound[team].spy }}!
        </div>
        <br />
      </template>
      <button class="button" @click="newRound">Next round</button>
    </div>
  </div>
</body>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<!-- My code -->
<script>
  window.COLLECTION = 'incrypt';
</script>
<script type="module" src="firebase-network.js"></script>
<script type="module">
  import { nouns, compounds, verbs, adjectives } from './many-words.js';
  import {
    setRoom,
    updateRoom,
    getRoom,
    listRooms,
    listenRoom,
    unlistenRoom,
    listenForLogin,
  } from './firebase-network.js';

  /**
  Room: {
    name: 'apple',
    redTeam: {
      // Red team goes first on intercepts (TODO alternate?)
      // TODO name: 'Ugliest Carriages'
      players: ['alice', 'bob'], // First player is team lead aka mod
      words: ['student', 'bible', 'catholic', 'eraser'],
      intercepted: 0,
      dropped: 1,
    },
    blueTeam: ...
    currentRound: {
      state: 'ENCODING', // or 'NOT_STARTED'/'RED_INTERCEPT'/'BLUE_INTERCEPT'/'DECODING'/'DONE'
      redTeam: {
        spy: 'alice',
        key: [4, 1, 2], // sometimes referred to as "message"
        encode: ['gone', 'lazy', 'book'],
        // intercept and decode start like keys [3, 2, 4].
        // But extension would be individualized voting:
        intercept: {
          // TODO: Spy breaks ties? or mod? or first submitted? or random?
          alice: [2, 3, 1],
          bob: [2, 4, 1],
        },
        decode: {
          bob: [3, 1, 2],
        }
      },
      blueTeam: {...}
    }
    history: [{round1}, ...]
  }
  */
  const vueApp = new Vue({
    el: '#vue',
    data: {
      nouns,
      player: {
        name: 'alice',
        // Local values, before they get uploaded
        encode: [],
        intercept: [],
        decode: [],
      },
      room: exampleRoom(),
    },
    async created() {
      this.KEY_LENGTH = 3;
      this.WORDS_SHOWN = 4;
      // For now, always start by overwriting with the example room
      await setRoom(this.room);
    },
    methods: {
      async resetRoom() {
        this.room = {
          name: this.room.name,
          redTeam: {
            name: 'Red',
            players: [],
            words: randomWords(4),
            intercepted: 0,
            dropped: 0,
          },
          blueTeam: {
            name: 'Blue',
            players: [],
            words: randomWords(4),
            intercepted: 0,
            dropped: 0,
          },
          currentRound: {
            // Some dummy variables so Vue is happy.
            state: 'NOT_STARTED',
            redTeam: {},
            blueTeam: {},
          },
          history: [],
        };
        await setRoom(this.room);
      },
      async joinTeam(team) {
        this.room[team].players.push(this.player.name);
        // Also remove from existing team
        unpush(this.room[other(team)].players, this.player.name);
        await this.saveRoom('redTeam.players', 'blueTeam.players');
      },
      async submitEncode() {
        this.myTeamRound.encode = this.player.encode;
        await this.saveRoom(`currentRound.${this.myTeamId}.encode`);

        // If both spies have finished encoding, move on to the next stage
        if (this.theirTeamRound.encode.length === this.myTeamRound.encode.length) {
          this.room.currentRound.state = 'RED_INTERCEPT';
          await this.saveRoom('currentRound.state');

          // Temp filling in, TODO remove
          this.room.history.push(this.room.currentRound);
        }
      },
      async submitIntercept() {
        // TODO red intercept should lead to blue intercept; blue => decoding
        // TODO interception should obviate decoding
        if (this.myTeamId == 'redTeam') {
          // Save the result
          this.myTeamRound.intercept = this.player.intercept;
          await this.saveRoom('currentRound.redTeam.intercept');

          if (keysEqual(this.myTeamRound.intercept, this.theirTeamRound.key)) {
            // TODO: watch out for race conditions where two intercepts
            // are submitted simultaneously...
            // Like if the "Submit" button is double-clicked...
            this.myTeam.intercepted += 1;
            await this.saveRoom(`${this.myTeamId}.intercepted`);
          }

          // Move on to decoding
          this.room.currentRound.state = 'DECODING';
          await this.saveRoom('currentRound.state');
        }
      },
      async submitDecode() {
        this.myTeamRound.decode = this.player.decode;
        await this.saveRoom(`currentRound.${this.myTeamId}.decode`);

        // If both teams have finished decoding, the round is over!
        if (this.theirTeamRound.decode.length === this.myTeamRound.decode.length) {
          // Score the teams
          for (const team of ['redTeam', 'blueTeam']) {
            if (!keysEqual(this.room.currentRound[team].decode, this.room.currentRound[team].key)) {
              this.room[team].dropped += 1;
              await this.saveRoom(`${team}.intercepted`);
            }
          }

          this.room.currentRound.state = 'DONE';
          await this.saveRoom('currentRound.state');
        }
      },
      async newRound(saveCurrentRound = true) {
        if (saveCurrentRound) {
          this.room.history.push(this.room.currentRound);
        }
        this.room.currentRound = {
          state: 'ENCODING',
          redTeam: {
            spy: nextSpy(this.room.currentRound.redTeam.spy, this.room.redTeam.players),
            key: randomKey(this.KEY_LENGTH, this.WORDS_SHOWN),
            encode: [],
            intercept: [],
            decode: [],
          },
          blueTeam: {
            spy: nextSpy(this.room.currentRound.blueTeam.spy, this.room.blueTeam.players),
            key: randomKey(this.KEY_LENGTH, this.WORDS_SHOWN),
            encode: [],
            intercept: [],
            decode: [],
          },
        };
        // TODO when we're tracking separate rooms
        // this.room.lastUpdateTime = Date.now();

        // Overwrite existing room;
        await setRoom(this.room);
      },
      // Sync any number of properties of this.room to firebase
      async saveRoom(...props) {
        await updateRoom(this.room, Object.fromEntries(props.map((prop) => [prop, getIn(this.room, prop)])));
      },
      other,
      keysEqual,
    },
    computed: {
      isRed() {
        return this.room.redTeam.players.includes(this.player.name);
      },
      // Pros of room.redTeam separate from room.currentRound.redTeam:
      // - Easier history (?)
      // Cons:
      // - Uglier syntax
      // So maybe can refactor

      myTeamId() {
        return this.isRed ? 'redTeam' : 'blueTeam';
      },
      theirTeamId() {
        return this.isRed ? 'blueTeam' : 'redTeam';
      },
      myTeam() {
        return this.room[this.myTeamId];
      },
      theirTeam() {
        return this.room[this.theirTeamId];
      },
      myTeamRound() {
        return this.room.currentRound[this.myTeamId];
      },
      theirTeamRound() {
        return this.room.currentRound[this.theirTeamId];
      },
    },
  });

  function exampleRoom() {
    return {
      name: 'apple',
      redTeam: {
        // Red team goes first on intercepts (TODO alternate?)
        // TODO name: 'Ugliest Carriages'
        name: 'Red',
        players: ['alice', 'bob'], // First player is team lead aka mod
        words: ['student', 'bible', 'catholic', 'eraser'],
        intercepted: 0,
        dropped: 0,
      },
      blueTeam: {
        name: 'Blue',
        players: ['carol', 'david'], // First player is team lead aka mod
        words: ['four', 'google', 'vane', 'sand'],
        intercepted: 0,
        dropped: 0,
      },
      currentRound: {
        state: 'ENCODING', // or 'RED_INTERCEPT'/'BLUE_INTERCEPT'/'DECODING'/'DONE'
        redTeam: {
          spy: 'alice',
          key: [4, 1, 2],
          encode: ['gone', 'lazy', 'book'],
          intercept: [],
          decode: [],
        },
        blueTeam: {
          spy: 'carol',
          key: [1, 2, 4],
          encode: ['quad', 'lots', 'dry'],
          intercept: [],
          decode: [],
        },
      },
      history: [],
    };
  }

  function unpush(array, value) {
    const index = array.indexOf(value);
    if (index !== -1) {
      array.splice(index, 1);
    }
  }

  function other(team) {
    return team === 'redTeam' ? 'blueTeam' : 'redTeam';
  }

  // Extracts a node from an object tree by its path, like "redTeam.players"
  function getIn(object, path) {
    let node = object;
    for (const part of path.split('.')) {
      node = node[part];
    }
    return node;
  }

  // Keys are just arrays of ints
  function keysEqual(key1, key2) {
    if (key1.length !== key2.length) {
      return false;
    }
    for (let i = 0; i < key1.length; i++) {
      if (key1[i] !== key2[i]) {
        return false;
      }
    }
    return true;
  }

  function shuffleArray(array) {
    // From https://stackoverflow.com/a/12646864/1222351
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Unique list of random words e.g. randomWords(4) => ['at', 'lol', 'cat', 'yo']
  function randomWords(length) {
    const nounsCopy = nouns.slice();
    // Assumes nouns has no duplicates.
    return shuffleArray(nounsCopy).slice(0, length);
  }

  // Key elements will be unique e.g. randomKey(3, 4) => [2, 1, 4]
  function randomKey(length, max) {
    if (length > max) {
      throw "Can't have a longer key than # of words shown!";
    }

    // Generate a list from [1...max], then shuffle, then slice.
    const sequential = [...Array(max).keys()].map((i) => i + 1);
    return shuffleArray(sequential).slice(0, length);
  }

  function nextSpy(lastSpy, players) {
    const nextIndex = (players.indexOf(lastSpy) + 1 + players.length) % players.length;
    return players[nextIndex];
  }
</script>
