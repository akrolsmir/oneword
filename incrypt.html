<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>Incrypt</title>
  <link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html {
      margin: 0;
      height: 100%;
      /* Maybe palette: https://coolors.co/acad94-db162f-d8d4d5-5f758e-383961 */
      background-color: #d8d4d5;
      position: relative;
      overflow: auto;
    }

    h1,
    h2,
    h3 {
      font-family: 'Merienda One', cursive;
    }

    h1 {
      font-size: 40px;
    }

    h2 {
      margin-top: 16px;
      font-size: 24px;
    }

    body {
      margin: 48px auto;
      width: 600px;
      max-width: 95vw;
    }

    /* Narrow the gap between words */
    .words {
      margin: -0.25rem;
    }

    .words > .column {
      padding: 0.25rem;
    }

    [v-cloak] {
      display: none;
    }
  </style>

  <!-- Shark favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f988.png" />
</head>

<body class="has-navbar-fixed-top">
  <h1>Welcome to Incrypt</h1>
  <div id="vue">
    <h2>Room: {{ room.name }}. Your name: <input class="input" v-model="player.name" /></h2>
    <br />
    <!-- Team rosters -->
    <div class="columns">
      <div class="column" v-for="team in ['redTeam', 'blueTeam']">
        <h3>
          {{ room[team].name }} team: {{ room[team].players.join(', ') }}
          <a v-if="!room[team].players.includes(player.name)" @click="joinTeam(team)">(join)</a>
        </h3>
        üëª {{ intercepted(other(team), room.history) }} interceptions (2 to win) <br />
        ü§¶‚Äç‚ôÄÔ∏è {{ dropped(team, room.history) }} dropped messages (2 to lose)
        <br />
      </div>
    </div>

    <br /><br />

    <div v-if="room.state !== 'NOT_STARTED'" class="mb-2">
      <!-- Show the current words -->
      <div v-if="isPlaying" class="columns words">
        <div class="column" v-for="(word, i) in myTeam.words">
          <div class="notification" :class="isRed ? 'is-danger' : 'is-info'">
            <small>Word {{ i + 1 }}</small>
            <h2>{{ word }}</h2>
          </div>
        </div>
      </div>

      <!-- Show the current state of the game -->
      Round {{ room.history.length + 1 }}:
      <span v-if="room.state === 'ENCODING'"><b>üîè Incrypt</b></span>
      <span v-else>Incrypt</span> -
      <template v-if="room.history.length === 0">
        <span v-if="room.state === 'BOTH_DECODE'"><b>üî¥üîµ Decrypt</b></span>
        <span v-else>Decrypt</span> -
      </template>
      <template v-else>
        <span v-if="room.state === 'RED_DECODE'"><b>üî¥ Decrypt Red</b></span>
        <span v-else>Decrypt Red</span> -
        <span v-if="room.state === 'BLUE_DECODE'"><b>üîµ Decrypt Blue</b></span>
        <span v-else>Decrypt Blue</span> -
      </template>
      <span v-if="room.state === 'DONE'"><b>‚úîÔ∏è Debrief</b></span>
      <span v-else>Debrief</span>

      <!-- Show the timer. -->
      <timer
        :length="room.timerLength"
        :on-finish="nextState"
        v-if="room.timerLength > 0 && room.state !== 'DONE'"
        :key="room.state"
      ></timer>
    </div>
    <!-- Pre-game: Waiting for players -->
    <div v-if="room.state === 'NOT_STARTED'" class="box">
      <div v-if="room.redTeam.players.length < 2 ">
        {{ room.redTeam.name }} team needs {{ 2 - room.redTeam.players.length }} more, before we can start!
      </div>
      <div v-else-if="room.blueTeam.players.length < 2 ">
        {{ room.blueTeam.name }} team needs {{ 2 - room.blueTeam.players.length }} more, before we can start!
      </div>
      <div v-else>
        Awesome! There are {{ room.redTeam.players.length }} players on {{ room.redTeam.name }} and {{
        room.blueTeam.players.length }} players on {{ room.blueTeam.name }}.
        <br /><br />
        Ready to start?
        <br />
        <button class="button" @click="newRound">Start game!</button>
      </div>
    </div>
    <!-- Part 1: Spies are encoding their messages -->
    <div v-cloak v-if="room.state === 'ENCODING'" class="box">
      <div v-if="player.name === myTeam.round.spy">
        <h3>You are the {{ myTeam.name }} spy! Incrypt for your team: "{{ myTeam.round.key.join(' - ') }}"</h3>
        <br />
        <div class="columns">
          <div class="column" v-for="(digit, i) in myTeam.round.key">
            <input class="input" v-model="player.encode[i]" @keyup.enter="submitEncode" />
            <br /><br />
            <b>{{ digit }} - {{ myTeam.words[digit - 1] }}</b>
            <ul>
              <li v-for="(entry, e) in room.history" v-if="entry[myTeamId].round.key.includes(digit)">
                {{ entry[myTeamId].round.encode[entry[myTeamId].round.key.indexOf(digit)] }}
              </li>
            </ul>
          </div>
          <div class="column">
            <button
              class="button"
              @click="submitEncode()"
              :class="finished('encode', myTeam.round) ? 'is-success' : ''"
            >
              Incrypt
            </button>
          </div>
        </div>
        <!-- Remind spy of the rules -->
        <div class="content">
          <b>Rules</b>
          <ul>
            <li>Your incryptions should relate to the <i>meaning</i> of each word</li>
            <li>NOT its <i>number</i>, <i>rhymes</i>, or <i>homonyms</i></li>
            <li>Don't reuse words or past incryptions!</li>
          </ul>
        </div>
      </div>
      <div v-else>
        <h3>Waiting for {{ myTeam.round.spy }} to incrypt the key...</h3>
        <!-- Section: Show past clues, so teammates can think -->
        <div v-if="room.history.length > 0" class="columns mt-2">
          <div class="column" v-for="(word, i) in myTeam.words">
            <b>{{ i + 1 }} - {{ word }}</b>
            <ul>
              <li v-for="(entry, e) in room.history" v-if="entry[myTeamId].round.key.includes(i + 1)">
                {{ entry[myTeamId].round.encode[entry[myTeamId].round.key.indexOf(i + 1)] }}
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div v-if="['RED_DECODE', 'BLUE_DECODE', 'BOTH_DECODE'].includes(room.state)" class="box">
      <!-- Parts 2 and 4: Other team tries to intercept -->
      <div v-if="myTeamId !== smugglers">
        <!-- Section: Show the smugglers' code -->
        <h3>
          The {{ otherTeam.name }} spy incrypted: "{{ otherTeam.round.encode.join(' - ') }}". Try intercepting it:
        </h3>
        <br />
        <!-- Section: Vote for the code -->
        <div class="columns">
          <div class="column" v-for="(encoded, e) in otherTeam.round.encode">
            <h3>"{{ encoded }}"</h3>
            <div class="select">
              <select v-model="player.intercept[e]">
                <option v-for="(word, i) in otherTeam.words" :value="i + 1">Word {{ i + 1 }}</option>
              </select>
            </div>
          </div>
          <div class="column">
            <br />
            <button
              class="button"
              @click="submitIntercept()"
              :class="finished('intercept', otherTeam.round) ? 'is-success' : ''"
            >
              Intercept
            </button>
          </div>
        </div>
        <br />
        <!-- Section: See all past clues -->
        <div class="columns">
          <div class="column" v-for="(word, i) in otherTeam.words">
            <b>Word {{ i + 1 }}</b>
            <ul>
              <li v-for="(entry, e) in room.history" v-if="entry[other(myTeamId)].round.key.includes(i + 1)">
                {{ entry[other(myTeamId)].round.encode[entry[other(myTeamId)].round.key.indexOf(i + 1)] }}
              </li>
            </ul>
          </div>
        </div>
      </div>
      <!-- Parts 2 and 4: Meanwhile, the smugglers tries to decrypt the key -->
      <div v-else>
        <div v-if="player.name === myTeam.round.spy">
          <h3>Waiting for your teammates to decrypt your message...</h3>
        </div>
        <div v-else>
          <h3>Decrypt what {{ myTeam.round.spy }} meant by "{{ myTeam.round.encode.join(' - ') }}":</h3>
          <br />
          <!-- (TODO: deduplicate or component-ize with above) -->
          <!-- Section: Vote for the code -->
          <div class="columns">
            <div class="column" v-for="(encoded, e) in myTeam.round.encode">
              <h3>"{{ encoded }}"</h3>
              <div class="select">
                <select v-model="player.decode[e]">
                  <option v-for="(word, i) in myTeam.words" :value="i + 1">{{i + 1 }} - {{ word }}</option>
                </select>
              </div>
            </div>
            <div class="column">
              <br />
              <button
                class="button"
                @click="submitDecode(myTeamId)"
                :class="finished('decode', myTeam.round) ? 'is-success' : ''"
              >
                Decrypt
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Results for both teams! -->
    <div v-if="room.state === 'DONE'" class="box">
      <h2>Round {{ room.history.length + 1 }} debrief</h2>
      <br />
      <template v-for="team in ['redTeam', 'blueTeam']">
        <b>{{ room[team].name }} team's message was "{{ room[team].round.key.join(' - ') }}"</b>
        <br />
        {{ room[team].round.spy }} incrypted it as "{{ room[team].round.encode.join(' - ') }}"
        <div v-if="keysEqual(room[team].round.intercept, room[team].round.key)">
          üëª {{ room[other(team)].name }} team intercepted the message!
        </div>
        <div v-else-if="room[team].round.intercept.length > 0">
          {{ room[other(team)].name }} team tried to intercept with
          <span>"{{ room[team].round.intercept.join(' - ') }}"</span>
        </div>
        <div v-if="keysEqual(room[team].round.decode, room[team].round.key)">
          {{ room[team].name }} team succesfully decoded their message~
        </div>
        <div v-else>ü§¶‚Äç‚ôÄÔ∏è {{ room[team].name }} team thought it was "{{ room[team].round.decode.join(' - ') }}"...</div>
        <br />
      </template>
      <!-- Game over -->
      <div v-if="gameOver">
        <h2>Game Over</h2>
        <template v-for="team in ['redTeam', 'blueTeam']">
          <b>{{ room[team].name }} team has {{ points(team) }} points.</b><br />
          + {{ intercepted(other(team), room.history) }} üëª interceptions<br />
          ‚àí {{ dropped(team, room.history) }} ü§¶‚Äç‚ôÄÔ∏è dropped messages<br />
          <br />
        </template>
        <div v-if="points('redTeam') === points('blueTeam')">
          <h2>It's a tie!</h2>
          The tiebreaker is which team can guess more of the other team's words.
        </div>
        <div v-else>
          <h2>{{ points('redTeam') > points('blueTeam') ? room.redTeam.name : room.blueTeam.name }} team wins!</h2>
          Congratulations! GG and well played~
        </div>
      </div>
      <button v-else class="button" @click="newRound">Next round</button>
    </div>

    <!-- Mod tools -->
    <div class="notification" v-if="player.name === 'Austin'">
      <h2>Mod tools</h2>
      <br />
      <div class="columns">
        <div class="column">
          <button class="button is-small is-danger" @click="resetRoom">Reset game</button>
        </div>
        <div class="column">
          <button class="button is-small" @click="nextState">Next stage</button>
        </div>
        <div class="column"><input class="input is-small" v-model.number="room.timerLength" /> second timer</div>
      </div>
    </div>

    <!-- History -->
    <div v-if="room.history.length > 0">
      <h2>History</h2>
      <template v-for="(past, p) of room.history.slice().reverse()">
        <div class="columns">
          <div class="column" v-for="team in ['redTeam', 'blueTeam']">
            <h3>Round {{ room.history.length - p }}: {{ room[team].name }} team</h3>
            <table class="table is-fullwidth is-striped">
              <tbody>
                <thead>
                  <th>üîè {{ past[team].round.spy }}</th>
                  <!-- TODO: maybe emojize more -->
                  <th>{{ team === 'redTeam' ? 'üîµ' : 'üî¥' }}</th>
                  <th>{{ team === 'redTeam' ? 'üî¥' : 'üîµ' }}</th>
                  <th>‚úîÔ∏è</th>
                </thead>
                <tr v-for="(encoded, e) in past[team].round.encode">
                  <td>{{ encoded }}</td>
                  <td>{{ past[team].round.intercept[e] }}</td>
                  <td>{{ past[team].round.decode[e] }}</td>
                  <td>{{ past[team].round.key[e] }}</td>
                </tr>
              </tbody>
            </table>
            <div v-if="keysEqual(past[team].round.intercept, past[team].round.key)">
              üëª {{ room[other(team)].name }} team intercepted the message!
            </div>
            <div v-if="!keysEqual(past[team].round.decode, past[team].round.key)">
              ü§¶‚Äç‚ôÄÔ∏è {{ room[team].name }} team thought it was "{{ past[team].round.decode.join(' - ') }}"...
            </div>
          </div>
        </div>
      </template>
    </div>
  </div>
</body>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<!-- My code -->
<script>
  window.COLLECTION = 'incrypt';
</script>
<script type="module">
  import './components/timer.js';
  import { nouns, compounds, verbs, adjectives } from './many-words.js';
  import {
    setRoom,
    updateRoom,
    getRoom,
    listRooms,
    listenRoom,
    unlistenRoom,
    listenForLogin,
  } from './firebase-network.js';

  /**
  Room: {
    name: 'apple',
    state: 'ENCODING', // or 'NOT_STARTED'/'RED_DECODE'/'BLUE_DECODE'/'BOTH_DECODE/'DONE'
    redTeam: {
      // Red team goes first on intercepts (TODO alternate?)
      // TODO name: 'Ugliest Carriages', emoji: 'ü§¶‚Äç‚ôÄÔ∏è', color: '#FF4422'
      players: ['alice', 'bob'], // First player is team lead aka mod
      words: ['student', 'bible', 'catholic', 'eraser'],
      intercepted: 0,
      dropped: 1,
      round: {
        spy: 'alice',
        key: [4, 1, 2], // sometimes referred to as "message"
        encode: ['gone', 'lazy', 'book'],
        // intercept and decode start like keys [3, 2, 4].
        // But TODO extension would be individualized voting:
        intercept: {
          // TODO: Spy breaks ties? or mod? or first submitted? or random?
          carol: [2, 3, 1],
          dave: [2, 4, 1],
        },
        decode: {
          bob: [3, 1, 2],
        }
    },
    blueTeam: ...
    history: [{
      redTeam: { round: {...} }
      blueTeam: { round: {...} }
    }, ...]
  }
  */
  const vueApp = new Vue({
    el: '#vue',
    data: {
      nouns,
      player: {
        name: '',
        // Local values, before they get uploaded
        encode: [],
        intercept: [],
        decode: [],
      },
      room: {
        // See below in created()
        name: 'banana',
      },
    },
    async created() {
      this.KEY_LENGTH = 3;
      this.WORDS_SHOWN = 4;

      // For now, always start by listening to the 'banana' example room
      const room = await getRoom(this.room);
      if (room) {
        this.room = room;
      } else {
        // Create a new room
        await this.resetRoom();
      }
      listenRoom(this);
    },
    async mounted() {
      const parsedUrl = new URL(window.location.href);
      const roomName = parsedUrl.searchParams.get('room');
      const playerName = parsedUrl.searchParams.get('player');
      if (playerName) {
        this.player.name = playerName;
      }
      if (roomName) {
        this.room.name = roomName;
      }
    },
    watch: {
      'room.state'(state) {
        this.$emit('reset-timer');
        // Clean up past inputs on each new round.
        if (state === 'DONE') {
          this.player.encode = [];
          this.player.intercept = [];
          this.player.decode = [];
        }
      },
    },
    methods: {
      async resetRoom() {
        this.room = {
          name: this.room.name,
          state: 'NOT_STARTED',
          redTeam: {
            name: 'Red',
            players: [],
            words: randomWords(4),
            intercepted: 0,
            dropped: 0,
            // Current round
            round: {},
          },
          blueTeam: {
            name: 'Blue',
            players: [],
            words: randomWords(4),
            intercepted: 0,
            dropped: 0,
            round: {},
          },
          history: [],
          timerLength: 10,
        };
        await setRoom(this.room);
      },
      async nextState() {
        // Figure out what the next state should be, then go there.
        const toUpdate = ['state'];
        const next = {
          ENCODING: this.room.history.length > 0 ? 'RED_DECODE' : 'BOTH_DECODE',
          RED_DECODE: 'BLUE_DECODE',
          // TODO RED_DONE?
          BLUE_DECODE: 'DONE',
          BOTH_DECODE: 'DONE',
          DONE: 'ENCODING',
        };
        this.room.state = next[this.room.state];
        if (this.room.state === 'DONE') {
          // Add current round to history on DONE, to update victory conditions
          this.room.history.push({
            redTeam: {
              round: this.room.redTeam.round,
            },
            blueTeam: {
              round: this.room.blueTeam.round,
            },
          });
          toUpdate.push('history');
        }
        await this.saveRoom(...toUpdate);
      },
      async joinTeam(team) {
        this.room[team].players.push(this.player.name);
        // Also remove from existing team
        unpush(this.room[other(team)].players, this.player.name);
        await this.saveRoom('redTeam.players', 'blueTeam.players');
      },
      async submitEncode() {
        this.myTeam.round.encode = this.player.encode;
        await this.saveRoom(`${this.myTeamId}.round.encode`);

        // Once both spies are done, move to intercepting (or straight to decoding in round 1)
        if (this.otherTeam.round.encode.length === this.myTeam.round.encode.length) {
          await this.nextState();
        }
      },
      async submitIntercept() {
        this.otherTeam.round.intercept = this.player.intercept;
        await this.saveRoom(`${other(this.myTeamId)}.round.intercept`);
        await this.checkIfDecrypted();
      },
      async submitDecode() {
        this.myTeam.round.decode = this.player.decode;
        await this.saveRoom(`${this.myTeamId}.round.decode`);
        await this.checkIfDecrypted();
      },
      async checkIfDecrypted() {
        if (!['RED_DECODE', 'BLUE_DECODE', 'BOTH_DECODE'].includes(this.room.state)) {
          console.error('intercept or decode called from invalid round!');
          return;
        }

        const team = this.smugglers;
        if (this.room.state === 'BOTH_DECODE') {
          if (!finished('decode', this.myTeam.round) || !finished('decode', this.otherTeam.round)) {
            // Only move forward when both teams are finished decoding
            return;
          }
        } else if (!finished('decode', this.room[team].round) || !finished('intercept', this.room[team].round)) {
          // Only move forward when decoding and intercepting are both finished
          return;
        }
        await this.nextState();
      },
      async newRound() {
        this.room.state = 'ENCODING';
        this.room.redTeam.round = {
          spy: nextSpy(this.room.redTeam.round.spy, this.room.redTeam.players),
          key: randomKey(this.KEY_LENGTH, this.WORDS_SHOWN),
          encode: [],
          intercept: [],
          decode: [],
        };
        this.room.blueTeam.round = {
          spy: nextSpy(this.room.blueTeam.round.spy, this.room.blueTeam.players),
          key: randomKey(this.KEY_LENGTH, this.WORDS_SHOWN),
          encode: [],
          intercept: [],
          decode: [],
        };
        // TODO when we're tracking separate rooms
        // this.room.lastUpdateTime = Date.now();

        // Overwrite existing room;
        await setRoom(this.room);
      },
      // Sync any number of properties of this.room to firebase
      async saveRoom(...props) {
        await updateRoom(this.room, Object.fromEntries(props.map((prop) => [prop, getIn(this.room, prop)])));
      },
      other,
      keysEqual,
      finished,
      intercepted,
      dropped,
      points(team) {
        return intercepted(other(team), this.room.history) - dropped(team, this.room.history);
      },
    },
    computed: {
      isRed() {
        return this.room.redTeam.players.includes(this.player.name);
      },
      isPlaying() {
        return this.isRed || this.room.blueTeam.players.includes(this.player.name);
      },
      myTeamId() {
        return this.isRed ? 'redTeam' : 'blueTeam';
      },
      myTeam() {
        return this.room[this.myTeamId];
      },
      otherTeam() {
        return this.room[other(this.myTeamId)];
      },
      smugglers() {
        // AKA interceptees
        const map = {
          RED_DECODE: 'redTeam',
          BLUE_DECODE: 'blueTeam',
          BOTH_DECODE: this.myTeamId,
        };
        return map[this.room.state];
      },
      gameOver() {
        return (
          // TODO: could extract 2 to a constant
          intercepted('redTeam', this.room.history) >= 2 ||
          dropped('redTeam', this.room.history) >= 2 ||
          intercepted('blueTeam', this.room.history) >= 2 ||
          dropped('blueTeam', this.room.history) >= 2
        );
      },
    },
  });

  function unpush(array, value) {
    const index = array.indexOf(value);
    if (index !== -1) {
      array.splice(index, 1);
    }
  }

  function other(team) {
    return team === 'redTeam' ? 'blueTeam' : 'redTeam';
  }

  // Extracts a node from an object tree by its path, like "redTeam.players"
  function getIn(object, path) {
    let node = object;
    for (const part of path.split('.')) {
      node = node[part];
    }
    return node;
  }

  // Keys are just arrays of ints
  // TODO wait, does the dropdown return a string? how does this work at all???
  // Maybe could use == instead of ===, cuz "3" == 3
  function keysEqual(key1, key2) {
    if (key1.length !== key2.length) {
      return false;
    }
    for (let i = 0; i < key1.length; i++) {
      if (key1[i] !== key2[i]) {
        return false;
      }
    }
    return true;
  }

  function shuffleArray(array) {
    // From https://stackoverflow.com/a/12646864/1222351
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Unique list of random words e.g. randomWords(4) => ['at', 'lol', 'cat', 'yo']
  function randomWords(length) {
    // For now, take out nouns longer than 8 letters; ~758 of 825 nouns left
    const filteredNouns = nouns.filter((word) => word.length <= 8);
    // Assumes nouns has no duplicates.
    return shuffleArray(filteredNouns).slice(0, length);
  }

  // Key elements will be unique e.g. randomKey(3, 4) => [2, 1, 4]
  function randomKey(length, max) {
    if (length > max) {
      throw "Can't have a longer key than # of words shown!";
    }

    // Generate a list from [1...max], then shuffle, then slice.
    const sequential = [...Array(max).keys()].map((i) => i + 1);
    return shuffleArray(sequential).slice(0, length);
  }

  function nextSpy(lastSpy, players) {
    const nextIndex = (players.indexOf(lastSpy) + 1 + players.length) % players.length;
    return players[nextIndex];
  }

  // keyType = 'encode', 'intercept', 'decode'
  function finished(keyType, round) {
    return round[keyType].length === vueApp.KEY_LENGTH;
  }

  // Returns how many of <team>'s messages have been intercepted
  function intercepted(team, history) {
    return history
      .map((entry) => keysEqual(entry[team].round.intercept, entry[team].round.key))
      .reduce((a, b) => a + b, 0);
  }

  // Returns how many of <team>'s messages have not been correctly decoded
  function dropped(team, history) {
    return history
      .map((entry) => !keysEqual(entry[team].round.decode, entry[team].round.key))
      .reduce((a, b) => a + b, 0);
  }
</script>
