<!DOCTYPE html>
<meta charset="utf-8" />

<head>
  <title>One Word</title>
  <link
    href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html {
      margin: 0;
      height: 100%;
      background-color: #faf6d8;
      position: relative;
      overflow: auto;
    }

    .fancy {
      font-family: 'Merienda One', cursive;
      margin-top: 16px;
      font-size: 24px;
    }

    .fancy.big {
      margin-top: 0;
      font-size: 40px;
    }

    .fancy.normal {
      margin-top: 0;
      font-size: 100%;
    }

    body {
      margin: 48px auto;
      width: 600px;
      max-width: 95vw;
    }

    .spacy {
      white-space: pre-wrap;
    }

    .label {
      margin-top: 20px;
    }

    .newline {
      white-space: pre-wrap;
    }

    .capitalize {
      text-transform: capitalize;
    }

    .comma:not(:last-child):after {
      content: ', ';
    }

    .tag {
      font-size: 0.875rem !important; /* Bulma's normal tag (0.75 rem) is too small and medium tag (1 rem) is too big */
    }

    #custom-word-tags {
      overflow-x: auto;
      max-height: 100px;
    }

    .halfOpacity {
      opacity: 0.5;
    }

    [v-cloak] {
      display: none;
    }
  </style>

  <meta name="description" content="You get to pick One Word. Make it count!" />

  <!-- Dolphin favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f42c.png" />
</head>

<body class="has-navbar-fixed-top">
  <div id="vue">
    <navbar ref="navbar" v-model="user"></navbar>
    <!-- Share Link Notification -->
    <div class="modal" :class="{'is-active': showShareModal}">
      <div class="modal-background" @click="showShareModal=false"></div>
      <div class="modal-content">
        <div class="notification">
          <label class="is-block mb-2">Invite your friends to play!</label>
          <sharelink :link="'https://oneword.games/?room=' + room.name"></sharelink>
          <button class="delete" aria-label="close" @click="showShareModal=false"></button>
        </div>
      </div>
    </div>
    <!-- Private Room Notification -->
    <div class="modal" :class="{'is-active': showPrivateModal}">
      <div class="modal-background" @click="showPrivateModal=false"></div>
      <div class="modal-card">
        <header class="modal-card-head">
          <p class="modal-card-title">Private room</p>
          <button class="delete" aria-label="close" @click="showPrivateModal=false"></button>
        </header>
        <section class="modal-card-body">
          This room is private. To join, ask your teammates for the room name or link.<br /><br />

          To make your own private room, become a supporter!<br />
        </section>
        <footer class="modal-card-foot">
          <button class="button is-warning" @click="referSupporter('private_room_modal')">Become a supporter</button>
        </footer>
      </div>
    </div>
    <!-- Home page -->
    <div v-if="!room.players" class="container mx-4">
      <!-- Announcements -->
      <div class="notification is-link has-text-centered">
        Join our official <a href="https://discord.gg/23wKGz2sNw">discord</a> to chat with other players!
      </div>

      <div class="fancy big">Welcome!</div>
      This is an online game based on
      <a target="_blank" rel="noopener noreferrer" href="https://amzn.to/2xV5lUm">Just One</a>, a co-op word game for 3+
      players.<br />
      In each of the 13 rounds, come up with a one-word hint for the guesser...<br />
      But beware: duplicate hints are discarded!<br />
      <form v-if="user.id || user.guest" @submit.prevent="enterRoom" method="POST">
        <label class="label">Player</label>
        <input class="input" type="text" v-model="player.name" placeholder="Ringo" />
        <label class="label">Room</label>
        <input class="input" type="text" v-model="room.name" placeholder="apple" required /><br /><br />
        <input class="button" type="submit" value="Enter Room" />
      </form>
      <template v-else>
        <br />
        <button class="button is-large is-success" @click="$refs.navbar.logIn()">Sign in to get started</button><br />
        <a @click='$set(user, "guest", true)' class="is-size-7">Play without an account</a>
      </template>

      <br /><br />
      <div v-cloak>
        <h2 class="fancy">Open Rooms</h2>
        <p v-for="openRoom in allRooms" v-bind:class="{ halfOpacity: isMuteOpenRoom(openRoom) }">
          <a @click="room.name = openRoom.name; enterRoom()"><b>{{ openRoom.name }}</b></a
          >, with {{ openRoom.players.join(', ') }} ({{ moment(openRoom.lastUpdateTime).fromNow() }})
        </p>
        <h2 class="fancy">Private Rooms</h2>
        <p v-for="privateRoom in privateRooms">
          <a @click="showPrivateModal = true"><b>{{ "Private room" }} with {{ privateRoom.players[0] }}</b></a>
          <span v-if="privateRoom.players.length > 1"> and {{ privateRoom.players.length }} others</span>
          ({{ moment(privateRoom.lastUpdateTime).fromNow() }})
        </p>
      </div>
      <br /><br /><br /><br /><br />
    </div>
    <!-- In game -->
    <div v-cloak v-else class="container mx-4">
      <div class="message">
        <!-- Room header -->
        <div class="message-header has-text-weight-normal is-flex-wrap-wrap">
          <h1 class="fancy big">{{ room.name }}</h1>
          <span class="fancy capitalize">Round {{ room.history.length + 1 }}</span>
          <!-- Navigation -->
          <span class="buttons are-small">
            <button class="button is-dark is-inverted is-outlined" @click="showShareModal=true">Invite</button>
            <button
              v-if="room.players.includes(player.name)"
              class="button is-dark is-inverted is-outlined"
              @click="kickPlayer(player.name)"
            >
              Watch
            </button>
            <button v-else class="button is-dark is-inverted is-outlined" @click="joinRoom">Rejoin</button>
            <button class="button is-danger is-inverted is-outlined" @click="kickPlayer(player.name); goHome();">
              Exit
            </button>
          </span>
        </div>
        <div>
          <div class="is-flex is-flex-wrap-wrap is-align-items-center">
            <!-- Supporter Settings -->
            <span
              title="Supporter settings"
              class="py-1 pl-1 pr-4"
              style="background: #ffef99; clip-path: polygon(0 0, 0 100%, 93% 100%, 100% 0)"
            >
              <div class="mx-1" v-if="isMod">
                <span class="select is-small">
                  <select v-model="room.public" @change="upsell('public')">
                    <option v-bind:value="true">Public</option>
                    <option v-bind:value="false">Private</option>
                  </select>
                </span>
                <span class="select is-small">
                  <select v-model="room.roundsInGame" @change="upsell('roundsInGame')">
                    <option v-bind:value="13">13 rounds</option>
                    <option v-bind:value="'Unlimited'">&infin; rounds</option>
                  </select>
                </span>
              </div>
              <template v-else>
                <span class="mx-2">{{ room.public ? 'Public' : 'Private' }} Room</span>
                <span class="mx-2">{{ room.roundsInGame == 'Unlimited' ? '&infin;' : room.roundsInGame}} rounds</span>
              </template>
            </span>

            <!-- Timers -->
            <span class="ml-1 mr-2 my-1 is-flex is-align-items-center">
              <template v-if="isMod">
                <label for="clue-timer" class="is-size-7 mx-1 is-flex-grow-1">Clue:</label>
                <input
                  class="input is-small"
                  style="flex: 1 2 48px"
                  id="clue-timer"
                  type="number"
                  min="1"
                  max="99"
                  placeholder="&infin;"
                  v-model.number="room.timers.CLUEING"
                  :disabled="room.timers.running"
                />
                <label for="guess-timer" class="is-size-7 mx-1 is-flex-grow-1">Guess:</label>
                <input
                  class="input is-small"
                  style="flex: 1 2 48px"
                  id="guess-timer"
                  type="number"
                  min="1"
                  max="99"
                  placeholder="&infin;"
                  v-model.number="room.timers.GUESSING"
                  :disabled="room.timers.running"
                />
                <button class="button is-small mx-1 is-flex-grow-1" @click="toggleTimers">
                  {{ room.timers.running ? 'Stop' : 'Start' }} Timers
                </button>
              </template>
              <template v-else>
                <template v-if="room.timers.running">
                  <span v-if="room.timers.CLUEING" class="mx-2">Clue: {{ room.timers.CLUEING }}s</span>
                  <span v-if="room.timers.GUESSING" class="mx-2">Guess: {{ room.timers.GUESSING }}s</span>
                </template>
                <span v-else class="mx-1">No timers</span>
              </template>
            </span>

            <!-- Categories -->
            <span v-if="isMod" class="field is-grouped is-grouped-multiline mx-3 my-1">
              <div class="control" v-for="category in this.CATEGORY_ORDER">
                <label class="capitalize checkbox">
                  <input type="checkbox" v-model="room.categories[category]" @change="saveRoom('categories')" />
                  {{ category }}
                </label>
              </div>
            </span>
            <span class="mx-3" v-else>
              <template v-for="(category, i) in this.CATEGORY_ORDER.filter(c => room.categories[c])">
                <span class="comma" :class="{'has-text-weight-bold': room.currentRound.category == category}">
                  {{ category }}</span
                >
              </template>
            </span>
          </div>
          <!-- Custom word editor (mod only) -->
          <div v-if="isMod && room.categories['custom']" class="is-flex is-justify-content-center">
            <div class="field mb-2" style="width: 500px; max-width: 90%">
              <div class="control">
                <textarea
                  class="textarea is-small mb-2"
                  :class="{'is-primary': wordsSaved}"
                  placeholder='Input your own word list e.g. "sneezy, phylum, europe, sloth, guacamole, data, colossus"...'
                  v-model="room.customWords"
                  @input="wordsSaved = false"
                ></textarea>
                <div id="custom-word-tags" class="tags mb-1">
                  <span class="tag is-info" v-for="word in customWordList.slice(0, 30)">{{ word }}</span>
                </div>
              </div>
              <div class="control">
                <button v-if="wordsSaved" class="button is-small" disabled>Saved</button>
                <button v-else class="button is-small" @click="wordsSaved = true; saveRoom('customWords');">
                  Save
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="message-body" style="border-width: 0">
          <!-- Players -->
          <div class="field is-grouped is-grouped-multiline">
            <span class="mb-2 mr-2">Players:</span>
            <nametag
              v-for="(player, i) in room.players"
              :name="player"
              :user="room.playerData && room.playerData[player]"
              :index="i"
              :submitted="!!room.currentRound.clues[player] || room.currentRound.guesser == player"
              :guessing="room.currentRound.guesser == player"
              :mod="isMod"
              @kick="kickPlayer(player)"
            ></nametag>
          </div>
          <!-- Other Mod Tools -->
          <div v-if="isMod">
            <div class="label">Room Controls</div>
            <div class="field has-addons is-inline-flex mb-0">
              <span class="control">
                <button class="button is-small" @click="nextStage">Next Stage</button>
              </span>
              <span class="control">
                <button class="button is-small" @click="newRound(true)">Skip Word</button>
              </span>
              <span v-if="this.user.supporter == 'ADMIN'" class="control">
                <button class="button is-small" @click="resetRoom">Reset Room</button>
              </span>
            </div>
            <div class="field has-addons is-inline-flex">
              <span class="control">
                <button class="button is-small" @click="makeMod(newMod)">Transfer Mod</button>
              </span>
              <span class="control">
                <span class="select is-small">
                  <select v-model="newMod">
                    <option v-for="player in this.room.players.slice(1)">{{ player }}</option>
                  </select>
                </span>
              </span>
            </div>
          </div>
        </div>
      </div>
      <timer :length="timerLength" :on-finish="nextStage" v-if="timerLength > 0" :key="room.currentRound.state"></timer>

      <!-- Input area (clueing) -->
      <div v-if="room.currentRound.state == 'CLUEING'">
        <div v-if="room.players.length < 3">
          <h2 class="fancy" role="alert">Waiting for 3 players...</h2>
          <p class="mt-5 mb-2">Invite your friends to play!</p>
          <sharelink :link="'https://oneword.games/?room=' + room.name"></sharelink>
        </div>
        <div v-else-if="room.currentRound.guesser == player.name">
          <h2 class="fancy" role="alert">It's your turn to guess! Waiting for clues...</h2>
        </div>
        <div v-else>
          <div class="box">
            <h2 class="fancy has-text-centered" role="alert">
              The {{ wordForWord(room.currentRound.category) }} for {{ room.currentRound.guesser }} is<br />
              <strong class="is-size-3">{{ room.currentRound.word }}</strong>
            </h2>
            <br />
            <label class="label" for="hintInput">Your clue</label>
            <div class="field has-addons">
              <div class="control is-expanded">
                <input
                  class="input"
                  id="hintInput"
                  type="text"
                  v-model="player.clue"
                  @keyup.enter="submitClue"
                  :class="{'is-primary': room.currentRound.clues[player.name]}"
                  :disabled="!room.players.includes(player.name)"
                />
              </div>
              <div class="control">
                <button
                  class="button"
                  @click="submitClue"
                  :disabled="!room.players.includes(player.name)"
                  :class="{'is-primary': room.currentRound.clues[player.name]}"
                >
                  Submit
                </button>
              </div>
            </div>
            <div class="notification is-danger" role="alert" v-if="hasSpecialCharacters(player.clue)">
              Are you sure this is a real word?
            </div>
          </div>
        </div>
      </div>

      <!-- Input area (guessing) -->
      <div v-if="room.currentRound.state == 'GUESSING'">
        <div v-if="room.currentRound.guesser == player.name">
          <div class="box">
            <h2 class="fancy" role="alert">Your clues for the {{ wordForWord(room.currentRound.category) }} are:</h2>
            <div class="fancy newline">{{ dedupe(room.currentRound.clues, false) }}</div>
            <label class="label" for="guess-input">Your Guess</label>
            <div class="field has-addons">
              <div class="control is-expanded">
                <input class="input" id="guess-input" type="text" v-model="player.guess" @keyup.enter="submitGuess" />
              </div>
              <div class="control">
                <button class="button" @click="submitGuess">Submit</button>
              </div>
            </div>
          </div>
        </div>
        <div v-else>
          <h2 class="fancy" role="alert">Waiting for {{ room.currentRound.guesser }} to guess...</h2>
          <div class="fancy">The clues for <strong>{{ room.currentRound.word }}</strong> were:</div>
          <div class="fancy newline">{{ dedupe(room.currentRound.clues) }}</div>
        </div>
      </div>

      <!-- Input area (done) -->
      <div v-if="room.currentRound.state == 'DONE'">
        <div v-if="correct(room.currentRound)">
          <h2 class="fancy has-text-success" role="alert">
            Correct! The word was "{{ room.currentRound.word }}". Good job!
          </h2>
        </div>
        <div v-else>
          <h2 class="fancy has-text-danger" role="alert">
            Aww, {{ room.currentRound.guesser }} guessed "{{ room.currentRound.guess }}", but it was "{{
            room.currentRound.word }}"...
          </h2>
        </div>
        <div class="fancy newline">{{ dedupe(room.currentRound.clues) }}</div>
        <br />
        <scoreboard
          v-if="isEnd(room)"
          :score="score(room)"
          :rounds-in-game="room.roundsInGame"
          :name="user.name && user.name.split(' ')[0]"
          :supporter="!!user.supporter"
          @continue-game="newRound(false)"
        ></scoreboard>
        <button v-else class="button" @click="newRound(false)">Next Round</button>
      </div>
      <br /><br />
      <!-- History -->
      <h2 v-if="room.history.length > 0" class="fancy">History</h2>
      <template v-for="(round, i) in room.history.slice().reverse()">
        <div class="level">
          <div class="level-left">
            <span class="level-item" style="justify-content: flex-start">
              <span
                class="icon"
                :class="correct(round) ? 'has-text-success' : 'has-text-danger'"
                :aria-label="correct(round) ? 'correct' : 'incorrect'"
              >
                {{ correct(round) ? 'âœ”' : 'âœ–' }}
              </span>
              <span class="fancy normal">{{ room.history.length - i }}. {{ round.word }} ({{ round.category }})</span>
            </span>
            <p class="level-item" style="justify-content: flex-start">
              {{ round.guesser }} guessed "<b :class="correct(round) ? 'has-text-success' : 'has-text-danger'"
                >{{ round.guess }}</b
              >"
            </p>
          </div>
        </div>
        <p class="newline">{{ dedupe(round.clues) }}</p>
        <br />
      </template>
    </div>
  </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert@2.1.2/dist/sweetalert.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.13.0/js/md5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pluralize@8.0.0/pluralize.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<!-- My code -->
<script type="module" src="firebase-network.js"></script>
<script type="module" src="components/nametag.js"></script>
<script type="module" src="components/navbar.js"></script>
<script type="module" src="components/timer.js"></script>
<script type="module" src="components/scoreboard.js"></script>
<script type="module" src="components/sharelink.js"></script>
<script type="module">
  import { nouns, compounds, verbs, adjectives } from './many-words.js';
  import {
    setRoom,
    updateRoom,
    getRoom,
    listRooms,
    listenRoom,
    unlistenRoom,
    listenForLogin,
  } from './firebase-network.js';

  /**
  Room: {
    name: apple,
      players: ['alice', 'bob', 'carol'],
      currentRound: {
        state: 'clueing' // or 'guessing', or 'done'
        guesser: 'alice',
        word: 'company'
        clues: {
          alice: 'corporation',
          bob: 'collected'
          carol: 'collected'
        }
      }
      history: [{round1}, ...]
    }
  */
  const vueApp = new Vue({
    el: '#vue',
    data: {
      user: {},
      allRooms: [],
      privateRooms: [],
      room: {
        name: randomWord('adjectives') + '-' + randomWord('nouns'),
        history: [],
      },
      player: {
        name: '',
        clue: '',
        guess: '',
      },
      showShareModal: false,
      showPrivateModal: false,
      newMod: '',
      wordsSaved: false,
    },
    created() {
      // global constant
      this.CATEGORY_ORDER = ['nouns', 'verbs', 'adjectives', 'compounds', 'custom'];
    },
    async mounted() {
      this.populateHome(); // Begin listing rooms, but don't wait for the result to mount
      const parsedUrl = new URL(window.location.href);
      const roomName = parsedUrl.searchParams.get('room');
      const playerName = parsedUrl.searchParams.get('player');
      if (playerName) {
        this.player.name = playerName;
      }
      if (roomName) {
        this.room.name = roomName;
        await this.enterRoom();
      }
    },
    watch: {
      'room.currentRound.state'(state) {
        this.$emit('reset-timer');
        // Clean up past inputs when the round moves forward.
        if (state == 'GUESSING') {
          this.player.clue = '';
        } else if (state == 'DONE') {
          this.player.guess = '';
        }
      },
    },
    computed: {
      timerLength() {
        if (this.room.currentRound && this.room.timers && this.room.timers.running) {
          return this.room.timers[this.room.currentRound.state];
        }
        return 0;
      },
      isMod() {
        if (this.user.supporter == 'ADMIN') {
          return true;
        }
        if (this.room && this.room.players) {
          return this.player.name == this.room.players[0];
        }
      },
      // Returns the set of open room names that matches the current `room.name`.
      filteredRoomNameSet() {
        const filtered = new Set();
        const roomNameRe = new RegExp(this.room.name, 'i');
        for (const openRoom of this.allRooms) {
          if (openRoom.name.match(roomNameRe)) {
            filtered.add(openRoom.name);
          }
        }
        return filtered;
      },
      customWordList() {
        // If there are any commas, parse as csv; else, parse with whitespace
        let words = this.room.customWords.split(',');
        if (words.length <= 1) {
          words = this.room.customWords.split(/\s/);
        }
        // Lowercase and trim out whitespace; take out empty words
        return words.map((w) => w.toLowerCase().trim()).filter((w) => w);
      },
    },
    methods: {
      md5,
      moment,
      listRooms,
      dedupe,
      async populateHome() {
        this.privateRooms = (await listRooms(5, false)).filter((room) => room.players.length > 0);
        this.allRooms = (await listRooms(20, true)).filter((room) => room.players.length > 0);
      },
      async enterRoom() {
        if (!this.player.name) {
          this.$refs.navbar.logIn();
          return;
        }
        // Sanitize room name
        this.room.name = this.room.name
          .trim()
          .toLowerCase()
          .replace(/\s/g, '-') // whitespace
          .replace(/[^\p{L}-]/gu, ''); // not (dash or letter in any language)

        const room = await getRoom(this.room);

        if (room) {
          // If the player's name collides with another user's,
          // prepend adjectives until it is unique
          while (
            room.players.includes(this.player.name) &&
            (this.user.guest || this.user.email != room.playerData[this.player.name].email)
          ) {
            this.player.name = capitalize(randomWord('adjectives')) + ' ' + this.player.name;
          }

          this.room = room;
          return await this.joinRoom();
        } else {
          // Create a new room
          listenRoom(this);
          return await this.resetRoom();
        }
      },
      async resetRoom() {
        this.room = {
          name: this.room.name,
          players: [this.player.name],
          currentRound: {
            state: 'CLUEING',
            guesser: this.player.name,
            guess: '',
            word: randomWord(),
            clues: {},
            category: 'nouns',
          },
          history: [],
          public: true,
          roundsInGame: 13,
          lastUpdateTime: Date.now(),
          timers: { CLUEING: '', GUESSING: '', DONE: '', running: false },
          categories: {
            nouns: true,
            verbs: false,
            adjectives: false,
            compounds: false,
            custom: false,
          },
          customWords: '',
          playerData: {
            [this.player.name]: {
              email: this.user.email || '',
              supporter: this.user.supporter || '',
            },
          },
        };
        await setRoom(this.room);
      },
      // Only call if room already exists.
      async joinRoom() {
        listenRoom(this);

        // migration
        if (!this.room.playerData) {
          this.room.playerData = {};
        }

        const { email = '', supporter = '' } = this.user;
        this.room.playerData[this.player.name] = { email, supporter };

        if (this.room.players.includes(this.player.name)) {
          await this.saveRoom('playerData');
        } else {
          this.room.players.push(this.player.name);
          await this.saveRoom('playerData', 'players');
        }
      },
      goHome() {
        unlistenRoom();
        this.room = { name: '' };
      },
      async kickPlayer(name) {
        if (this.room.players.includes(name)) {
          const index = this.room.players.indexOf(name);
          this.room.players.splice(index, 1);
          await this.saveRoom('players');
        }
      },
      async makeMod(name) {
        const index = this.room.players.indexOf(name);
        if (index >= 0) {
          // swap players[0] and players[index]
          [this.room.players[0], this.room.players[index]] = [this.room.players[index], this.room.players[0]];
          await this.saveRoom('players');
        }
      },
      wordForWord(category) {
        return (
          {
            nouns: 'word',
            verbs: 'verb',
            adjectives: 'adjective',
            compounds: 'compound',
            custom: 'word',
          }[category] || 'word'
        );
      },
      hasSpecialCharacters(word) {
        return /[\s~`!@#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?()\._]/g.test(word);
      },
      async submitClue() {
        this.player.clue = this.player.clue.toLowerCase().trim();
        const update = {};
        update[`currentRound.clues.${this.player.name}`] = this.player.clue;
        await updateRoom(this.room, update);

        // If all clues are in, move to guessing
        const doneCluing = this.room.players.every(
          (p) => this.room.currentRound.clues[p] || p == this.room.currentRound.guesser
        );
        if (doneCluing) {
          await updateRoom(this.room, { 'currentRound.state': 'GUESSING' });
        }
      },
      async nextStage() {
        if (this.room.currentRound.state == 'CLUEING') {
          return await updateRoom(this.room, { 'currentRound.state': 'GUESSING' });
        } else if (this.room.currentRound.state == 'GUESSING') {
          return await updateRoom(this.room, { 'currentRound.state': 'DONE' });
        } else {
          return await this.newRound();
        }
      },
      async submitGuess() {
        const update = {
          'currentRound.guess': this.player.guess.toLowerCase().trim(),
          'currentRound.state': 'DONE',
        };
        await updateRoom(this.room, update);
      },
      async newRound(sameGuesser = false) {
        this.room.history.push(this.room.currentRound);
        const category = nextCategory(this.room.categories);
        this.room.currentRound = {
          state: 'CLUEING',
          guesser: sameGuesser
            ? this.room.currentRound.guesser
            : nextGuesser(this.room.currentRound.guesser, this.room.players),
          guess: '',
          word: nextWord(this.room.history, category, this.customWordList),
          clues: {},
          category,
        };
        this.room.lastUpdateTime = Date.now();

        // Overwrite existing room;
        await setRoom(this.room);
      },
      async toggleTimers() {
        this.room.timers.running = !this.room.timers.running;
        await this.saveRoom('timers');
      },
      // Sync any number of properties of this.room to firebase
      async saveRoom(...props) {
        await updateRoom(this.room, Object.fromEntries(props.map((prop) => [prop, this.room[prop]])));
      },
      async upsell(...props) {
        if (this.user.supporter) {
          await this.saveRoom(...props);
        } else {
          const result = await swal({
            title: 'Want private rooms?',
            text: 'Earn perks like private rooms, custom avatars, and more by becoming a supporter ðŸ˜',
            buttons: {
              cancel: 'Not now',
              support: 'Okay!',
            },
          });
          if (result === 'support') {
            referSupporter('modtools');
          }
          // Reset UI to non-supporter defaults
          this.room.public = true;
          this.room.roundsInGame = 13;
        }
      },
      referSupporter,
      // Returns a bool indicating if the provided Room object should be muted due to not matching the
      // currently entered Room field. Will always return false if no open rooms match the current room name.
      isMuteOpenRoom: function (openRoom) {
        return this.filteredRoomNameSet.size != 0 && !this.filteredRoomNameSet.has(openRoom.name);
      },
      correct,
      isEnd,
      score,
    },
  });

  function referSupporter(source) {
    firebase.analytics().logEvent('view_promotion', {
      source: source,
    });
    window.open('./supporter.html', '_blank');
  }

  listenForLogin(vueApp);

  // Returns whether a round's guess is correct.
  function correct(round) {
    return pluralize.singular(round.guess) === round.word || pluralize.plural(round.guess) == round.word;
  }
  function totalRounds(room) {
    return room.roundsInGame == 'Unlimited' ? 1024 : room.roundsInGame;
  }
  function isEnd(room) {
    return (room.history.length + 1) % totalRounds(room) == 0;
  }
  function score(room) {
    return [...room.history, room.currentRound].slice(-totalRounds(room)).filter(correct).length;
  }

  // "ha" and "ha" are dupes, as are "gold" and "golden", but not "hahahaha" and "hah".
  function dupes(clue1, clue2) {
    if (clue1 == clue2) {
      return true;
    }
    if (clue1.length >= 3 && clue2.length >= 3 && (clue1.includes(clue2) || clue2.includes(clue1))) {
      return true;
    }
    return false;
  }

  // Return whether the candidate is a dupe of any of the existing clues.
  function anyDupes(clues, candidate) {
    return clues.some((c) => dupes(c, candidate));
  }

  function dedupe(clues, showCollisions = true) {
    const cluesToPlayers = {};
    for (const [player, clue] of Object.entries(clues)) {
      let foundDupe = false;
      for (const existingClue of Object.keys(cluesToPlayers)) {
        // If an existing dupe is found, join the strings into the new clue
        if (anyDupes(existingClue.split(' / '), clue)) {
          foundDupe = true;
          cluesToPlayers[existingClue].push(player);
          cluesToPlayers[existingClue + ' / ' + clue] = cluesToPlayers[existingClue];
          delete cluesToPlayers[existingClue];
          break;
        }
      }
      // Otherwise, create a new array for this clue.
      if (!foundDupe) {
        cluesToPlayers[clue] = [player];
      }
    }
    const deduped = Object.entries(cluesToPlayers)
      .filter(([clue, cluers]) => cluers.length == 1)
      .map(([clue, cluers]) => `${cluers[0]} - ${clue}`);
    const conflicts = Object.entries(cluesToPlayers)
      .filter(([clue, cluers]) => cluers.length > 1)
      .map(([clue, cluers]) => cluers.join(' & ') + (showCollisions ? ` - ${clue}` : ''));
    let result = showCollisions ? '' : '(Uh, good luck.)';
    if (deduped.length > 0) {
      result = `${deduped.join('\n')}`;
    }
    if (conflicts.length > 0) {
      result += `\n\nCollisions:\n${conflicts.join('\n')}`;
    }
    return result;
  }

  function nextGuesser(lastGuesser, players) {
    const nextIndex = (players.indexOf(lastGuesser) + 1 + players.length) % players.length;
    return players[nextIndex];
  }

  function randomWord(category = 'nouns', customWordList = []) {
    const categories = { nouns, compounds, verbs, adjectives, custom: customWordList };
    const words = categories[category];
    return words[Math.floor(Math.random() * words.length)].toLowerCase();
  }

  function nextWord(history, category = 'nouns', customWordList = []) {
    let word;
    let loops = 0;
    do {
      loops++;
      if (loops > 10000) {
        return "You're out of custom words...";
      }
      // TODO: consider generating a stable next word using seeded RNG.
      word = randomWord(category, customWordList);
    } while (history.map((round) => round.word).includes(word));
    return word;
  }

  function nextCategory(categories) {
    const enabled = Object.keys(categories).filter((c) => categories[c]);
    return enabled[Math.floor(Math.random() * enabled.length)];
  }

  function capitalize(str) {
    return str ? str[0].toLocaleUpperCase() + str.substring(1) : '';
  }
</script>
