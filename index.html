<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <title>One Word</title>
  <link href="https://fonts.googleapis.com/css?family=Fjalla+One|Merienda+One|Righteous|Sriracha&display=swap"
    rel="stylesheet">
  <script src="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.js"></script>
  <link rel="stylesheet" href="https://cdn.firebase.com/libs/firebaseui/3.5.2/firebaseui.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">
  <style>
    html {
      margin: 0;
      height: 100%;
      background-color: #f0e68c55;
      position: relative;
      overflow: auto;
    }

    h1, h2, h3 {
      font-family: 'Merienda One', cursive;
    }

    h1 {
      font-size: 40px;
    }

    h2 {
      margin-top: 16px;
      font-size: 24px;
    }

    body {
      margin: 48px auto;
      width: 600px;
    }

    .spacy {
      white-space: pre-wrap;
    }

    .label {
      margin-top: 20px;
    }

    .newline {
      white-space: pre;
    }

    .capitalize {
      text-transform: capitalize;
    }

    .panel {
      background-color: white;
    }


    [v-cloak] {
      display: none;
    }
  </style>

  <meta name="description" content="You get to pick One Word. Make it count!">

  <!-- Dolphin favicon courtesy of Twemoji -->
  <link rel="icon" href="https://twemoji.maxcdn.com/v/13.0.1/72x72/1f42c.png">
</head>

<body class="has-navbar-fixed-top">
  <div id="vue">
    <navbar ref="navbar" v-model="user"></navbar>
    <!-- Home page -->
    <div v-if="!room.players">
      <h1>Welcome!</h1>
      This is the online version of <a target="_blank" rel="noopener noreferrer" href="https://amzn.to/2xV5lUm">Just One</a>, a co-op word game for 3+ players.<br>
      In each of the 13 rounds, come up with a one-word hint for the guesser...<br>
      But beware: duplicate hints are discarded!<br>
      <template v-if="user.id || user.guest">
        <label class="label">Player</label>
        <input class="input" type="text" v-model="player.name" placeholder="Ringo">
        <label class="label">Room</label>
        <input class="input" type="text" v-model="room.name" placeholder="apple" @keyup.enter="enterRoom"><br><br>
        <button class="button" @click="enterRoom">Enter Room</button>
      </template>
      <template v-else>
        <br>
        <button class="button is-large is-success" @click="$refs.navbar.logIn()">Sign in to get started</button><br>
        <a @click='$set(user, "guest", true)' class="is-size-7">Guest account</a>
      </template>
      
      <br><br>
      <h2>Open Rooms</h2>
      <template v-for="openRoom in allRooms">
        <p>
          <a @click="room.name = openRoom.name; enterRoom()"><b>{{ openRoom.name }}</b></a>,
          with {{ openRoom.players.join(', ') }}
          ({{ moment(openRoom.lastUpdateTime).fromNow() }})
        </p>
      </template>
    </div>
    <!-- In game -->
    <div v-cloak v-else>
      <!-- Room header -->
      <article class="message">
        <div class="message-header">
          <h1>{{ room.name }}</h1>
          <h2 class="capitalize">Round {{ room.history.length + 1 }} ({{ room.currentRound.category }})</h2>
        </div>
        <div class="message-body">
          <template v-if="room.players.includes(player.name)">
            <b>{{ player.name }}</b>,
            you are
            {{ room.currentRound.guesser == player.name ? 'now guessing' : `clueing ${room.currentRound.guesser}` }}.
            <button class="button is-small" @click="kickPlayer(player.name)">Leave</button>
          </template>
          <template v-else>
            <button class="button" @click="goHome">Another Room</button>
            <button class="button" @click="joinRoom">Rejoin Game</button>
          </template>
          <br><br>
          Players:
          <template v-for="(player, i) in room.players">
            <avatar
              :name="player" 
              :email="room.namesToEmails && room.namesToEmails[player]"
              :index="i"
              :submitted="!!room.currentRound.clues[player] || room.currentRound.guesser == player">
            </avatar><span v-if="i + 1 < room.players.length">, </span>              
          </template>
        </div>
      </article>
      <timer :length='timerLength' :on-finish='nextStage' v-if="timerLength > 0" :key="room.currentRound.state"></timer>

      <!-- Input area (clueing) -->
      <div v-if="room.currentRound.state == 'CLUEING'">
        <div v-if="room.players.length < 3">
          <h2>Waiting for 3 players...</h2>
        </div>
        <div v-else-if="room.currentRound.guesser == player.name">
          <h2>Waiting for clues...</h2>
        </div>
        <div v-else>
          <div class="box">
            <h2>The word is "{{ room.currentRound.word }}"</h2><br>
            <label class="label">Your Clue</label>
            <div class="field has-addons">
              <div class="control is-expanded">
                <input class="input" type="text" v-model="player.clue" @keyup.enter="submitClue"
                  :class="{'is-primary': room.currentRound.clues[player.name]}" :disabled="!room.players.includes(player.name)">
              </div>
              <div class="control">
                <button class="button" @click="submitClue" :disabled="!room.players.includes(player.name)">Submit</button>
              </div>
            </div>
            <div class="notification is-danger" v-show="player.clue.includes(' ')">
              Is that really just one word?
            </div>
            <div class="notification is-danger" v-show="dupes(player.clue, room.currentRound.word)">
              Really?
            </div>
          </div>
        </div>
      </div>

      <!-- Input area (guessing) -->
      <div v-if="room.currentRound.state == 'GUESSING'">
        <div v-if="room.currentRound.guesser == player.name">
          <div class="box">
            <h2>Your clues are:</h2>
            <h2 class="newline">{{ dedupe(room.currentRound.clues, false) }}</h2>
            <label class="label">Your Guess</label>
            <div class="field has-addons">
              <div class="control is-expanded">
                <input class="input" type="text" v-model="player.guess" @keyup.enter="submitGuess">
              </div>
              <div class="control">
                <button class="button" @click="submitGuess">Submit</button>
              </div>
            </div>
          </div>
        </div>
        <div v-else>
          <h2>The clues were:</h2>
          <h2 class="newline">{{ dedupe(room.currentRound.clues) }}</h2>
          <h2>Waiting for {{ room.currentRound.guesser }} to guess...</h2>
        </div>
      </div>

      <!-- Input area (done) -->
      <div v-if="room.currentRound.state == 'DONE'">
        <div v-if="correct(room.currentRound)">
          <h2 class="has-text-success">Correct! The word was "{{ room.currentRound.word }}". Good job!</h2>
        </div>
        <div v-else>
          <h2 class="has-text-danger">Aww, {{ room.currentRound.guesser }} guessed "{{ room.currentRound.guess }}",
            but it was "{{ room.currentRound.word }}"...</h2>
        </div>
        <h2 class="newline">{{ dedupe(room.currentRound.clues) }}</h2>
        <br>
        <scoreboard v-if="isEnd(room)" :score="score(room)" :rounds-in-game="room.roundsInGame"
          @continue-game="newRound(false)"></scoreboard>
        <button v-else class="button" @click="newRound(false)">Next Round</button>
      </div>

      <br><br><br><br><br><br><br><br>

      <!-- Mod tools -->
      <nav class="panel" v-if="room.players[0] == player.name">
        <p class="panel-heading">Mod Tools</p>
        <div class="panel-block" style="background: #ffd70066;">
          <h3 style="padding-right: 20px;">Supporter Tools</h3>
          <div class="field is-horizontal has-addons">
            <div class="control">
              <button class="button is-small is-outlined is-inverted" @click="togglePublic" :disabled='!$refs.navbar.isSupporter'>
                {{ room.public ? 'Public' : 'Private' }} room
              </button>
            </div>
            <div class="control">
              <button class="button is-small" @click="showAvatar" :disabled='!$refs.navbar.isSupporter'>
                Show avatar
              </button>
            </div>
            <div class="control">
              <button class="button is-small" @click="setRounds" :disabled='!$refs.navbar.isSupporter'>
                {{ room.roundsInGame }} rounds
              </button>
            </div>
            <div class="control">
              <button class="button is-small" @click="shareRoom" :disabled='!$refs.navbar.isSupporter'>
                Share room link
              </button>
            </div>
          </div>
        </div>
        <div class="panel-block">
          <div class="field is-horizontal">
            <div class="field-body">
              <div class="field has-addons">
                <span class="control">
                  <button class="button is-small" @click="nextStage">Next Stage</button>
                </span>
                <span class="control">
                  <button class="button is-small" @click="newRound(true)">Skip Word</button>
                </span>
                <span class="control">
                  <button class="button is-small" @click="resetRoom">Reset Room</button>
                </span>
              </div>
              <div class="field has-addons" style="padding-left: 20px">
                <span class="control">
                  <button class="button is-small" @click="kickPlayer(player.kick)">Kick</button>
                </span>
                <span class="control">
                  <button class="button is-small" @click="makeMod(player.kick)">Transfer Mod</button>
                </span>
                <span class="control">
                  <input class="input is-small" type="text" v-model="player.kick" placeholder="Player Name">
                </span>
              </div>
            </div>
          </div>
        </div>
        <div class="panel-block">
          <div class="field is-horizontal">
            <label for="clue-timer" style="margin-right: 12px">Clue Timer:</label>
            <div class="field-body">
              
                <div class="control">
                  <input class="input is-small" id="clue-timer" type="number" min="1" max="999" placeholder="e.g. 30"
                      v-model.number="room.timers.CLUEING" :disabled="room.timers.running">
                </div>
              
            </div>
            <label for="guess-timer" style="margin-right: 12px">Guess Timer:</label>
            <div class="field-body">
              <div class="field is-grouped">
                <div class="control">
                  <input class="input is-small"  id="guess-timer" type="number" min="1" max="999" placeholder="e.g. 30"
                    v-model.number="room.timers.GUESSING" :disabled="room.timers.running">
                </div>
                <div class="control">
                  <button class="button is-small" @click="toggleTimers">{{ room.timers.running ? 'Stop' : 'Start' }} Timers</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="panel-block">
          <div class="field is-grouped is-horizontal">
            <template v-for="category in ['nouns', 'verbs', 'adjectives', 'compounds', 'custom']">
              <label class="capitalize">{{ category }}
                <input type="checkbox" v-model="room.categories[category]">
              </label>
            </template>
            <div class="control">
              <button class="button is-small" @click="setCategories()">Update Categories</button>
            </div>
          </div>
        </div>
        <div class="panel-block">
          <textarea class="textarea is-small has-fixed-size" placeholder="Input your own word list"
          v-model="room.customWords" :disabled="!room.categories.custom"></textarea>
        </div>
      </nav>

      <!-- History -->
      <h2>History</h2>
      <template v-for="(round, i) in room.history.slice().reverse()">
        <div class="level">
          <div class="level-left">
            <span class="icon level-item" :class="correct(round) ? 'has-text-success' : 'has-text-danger'">
              {{ correct(round) ? '✔' : '✖' }}
            </span>
            <h3 class="level-item">{{ room.history.length - i }}. {{ round.word }} ({{ round.category }})</h3>
            <p class="level-item">
              {{ round.guesser }} guessed "<b :class="correct(round) ? 'has-text-success' : 'has-text-danger'">{{ round.guess }}</b>"</p>
          </div>
        </div>
        <p class="newline">{{ dedupe(round.clues) }}</p>
        <br>
      </template>
    </div>
  </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert@2.1.2/dist/sweetalert.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.13.0/js/md5.min.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.8.1/firebase-firestore.js"></script>

<!-- My code -->
<script type="module" src="firebase-network.js"></script>
<script type="module" src="./navbar-vue.js"></script>
<script type="module" src="./timer-vue.js"></script>
<script type="module" src="./scoreboard-vue.js"></script>
<script type="module">
  import { nouns, compounds, verbs, adjectives } from './many-words.js';
  import { setRoom, updateRoom, getRoom, listRooms, listenRoom, unlistenRoom, listenForLogin } from './firebase-network.js';
  /**
   Room: {
     name: apple,
     players: ['alice', 'bob', 'carol'],
     currentRound: {
       state: 'clueing' // or 'guessing', or 'done'
       guesser: 'alice',
       word: 'company'
       clues: {
         alice: 'corporation',
         bob: 'collected'
         carol: 'collected'
       }
     }
     history: [{round1}, ...]
   }
  */
  const vueApp = new Vue({
    el: '#vue',
    data: {
      user: {},
      allRooms: [],
      room: {
        name: randomWord('adjectives') + '-' + randomWord('nouns'),
        history: [],
      },
      player: {
        name: '',
        clue: '',
        guess: '',
        kick: '',
      },
    },
    async mounted() {
      this.allRooms = await listRooms();
      const parsedUrl = new URL(window.location.href);
      const roomName = parsedUrl.searchParams.get('room');
      const playerName = parsedUrl.searchParams.get('player');
      if (playerName) {
        this.player.name = playerName;
      }
      if (roomName) {
        this.room.name = roomName;
        await this.enterRoom();
      }
    },
    watch: {
      'room.currentRound.state'(state) {
        this.$emit('reset-timer');
        // Clean up past inputs when the round moves forward.
        if (state == 'GUESSING') {
          this.player.clue = '';
        }
        else if (state == 'DONE') {
          this.player.guess = '';
        }
      },
    },
    computed: {
      timerLength() {
        if (this.room.currentRound && this.room.timers && this.room.timers.running) {
          return this.room.timers[this.room.currentRound.state];
        }
        return 0;
      }
    },
    methods: {
      md5,
      moment,
      listRooms,
      dupes,
      dedupe,
      async enterRoom() {
        if (!this.player.name) {
          this.$refs.navbar.logIn();
          return;
        }
        // Sanitize room name
        this.room.name = this.room.name
            .trim()
            .toLowerCase()
            .replace(/\s/g, "-") // whitespace
            .replace(/[^\p{L}-]/gu, ''); // not (dash or letter in any language)

        const room = await getRoom(this.room);
        if (room) {
          this.room = room;
          return await this.joinRoom();
        } else {
          // Create a new room
          listenRoom(this);
          return await this.resetRoom();
        }
      },
      async resetRoom() {
        this.room = {
          name: this.room.name,
          players: [this.player.name],
          currentRound: {
            state: 'CLUEING',
            guesser: this.player.name,
            guess: '',
            word: randomWord(),
            clues: {},
            category: 'nouns',
          },
          history: [],
          public: true,
          roundsInGame: 13,
          lastUpdateTime: Date.now(),
          timers: { 'CLUEING': '', 'GUESSING': '', 'DONE': '', running: false },
          categories: { 'nouns': true, 'verbs': false, 'adjectives': false, 'compounds': false, 'custom': false },
          customWords: '',
          namesToEmails: {}, // For rendering gravatars
        }
        await setRoom(this.room);
      },
      // Only call if room already exists.
      async joinRoom() {
        listenRoom(this);

        if (!this.room.players.includes(this.player.name)) {
          this.room.players.push(this.player.name);
          await updateRoom(this.room, { 'players': this.room.players });
        }
      },
      goHome() {
        unlistenRoom();
        this.room = { name: '' };
      },
      async kickPlayer(name) {
        if (this.room.players.includes(name)) {
          const index = this.room.players.indexOf(name);
          this.room.players.splice(index, 1);
          await updateRoom(this.room, { 'players': this.room.players });
        }
      },
      async makeMod(name) {
        if (this.room.players.includes(name)) {
          const index = this.room.players.indexOf(name);
          this.room.players[index] = this.player.name;
          this.room.players[0] = name;
          await updateRoom(this.room, { 'players': this.room.players });
        }
      },
      async submitClue() {
        this.player.clue = this.player.clue.toLowerCase().trim();
        const update = {};
        update[`currentRound.clues.${this.player.name}`] = this.player.clue;
        await updateRoom(this.room, update);

        // If all clues are in, move to guessing
        const doneCluing = this.room.players.every(p =>
          this.room.currentRound.clues[p] || p == this.room.currentRound.guesser);
        if (doneCluing) {
          await updateRoom(this.room, { 'currentRound.state': 'GUESSING' });
        }
      },
      async nextStage() {
        if (this.room.currentRound.state == 'CLUEING') {
          return await updateRoom(this.room, { 'currentRound.state': 'GUESSING' });
        } else if (this.room.currentRound.state == 'GUESSING') {
          return await updateRoom(this.room, {'currentRound.state': 'DONE'});
        } else {
          return await this.newRound();
        }
      },
      async submitGuess() {
        const update = {
          'currentRound.guess': this.player.guess.toLowerCase().trim(),
          'currentRound.state': 'DONE'
        };
        await updateRoom(this.room, update);
      },
      async newRound(sameGuesser = false) {
        this.room.history.push(this.room.currentRound);
        const category = nextCategory(this.room.categories);
        this.room.currentRound = {
          state: 'CLUEING',
          guesser: sameGuesser ? this.room.currentRound.guesser
            : nextGuesser(this.room.currentRound.guesser, this.room.players),
          guess: '',
          word: nextWord(this.room.history, category, this.room.customWords),
          clues: {},
          category,
        };
        this.room.lastUpdateTime = Date.now();

        // Overwrite existing room;
        await setRoom(this.room);
      },
      async toggleTimers() {
        this.room.timers.running = !this.room.timers.running;
        await updateRoom(this.room, { 'timers': this.room.timers });
      },
      async setCategories() {
        const update = {
          'categories': this.room.categories,
          'customWords': this.room.customWords,
        }
        await updateRoom(this.room, update);
      },
      async togglePublic() {
        this.room.public = !this.room.public;
        await updateRoom(this.room, { 'public': this.room.public });
      },
      async showAvatar() {
        if (!this.room.namesToEmails) {
          // TODO: Maybe remove null check after soaking a while?
          this.room.namesToEmails = {};
        }
        const email = this.$refs.navbar.value.email;
        this.room.namesToEmails[this.player.name] = email;
        await updateRoom(this.room, { namesToEmails: this.room.namesToEmails });
      },
      async setRounds() {
        if (this.room.roundsInGame != 13) {
          this.room.roundsInGame = 13;
        } else {
          this.room.roundsInGame = 'Unlimited';
        }
        await updateRoom(this.room, { 'roundsInGame': this.room.roundsInGame });
      },
      async shareRoom() {
        const link = document.createElement("input");
        link.value = `http://oneword.games/?room=${this.room.name}`;
        link.setAttribute('readonly', 'true');
        link.setAttribute('onclick', 'this.select()');
        link.setAttribute('size', '45');
        swal({
          title: "Share this link:",
          icon: "success",
          content: link
        });
      },
      correct,
      isEnd,
      score,
    }
  });

  listenForLogin(vueApp);

  // Returns whether a round's guess is correct.
  function correct(round) {
    return round.guess === round.word 
      || (["nouns", "compounds"].includes(round.category) && round.guess === round.word + "s");
  }
  function totalRounds(room) {
    return room.roundsInGame == "Unlimited" ? 1024 : room.roundsInGame;
  }
  function isEnd(room) {
    return (room.history.length + 1) % totalRounds(room) == 0
  }
  function score(room) {
    return [...room.history, room.currentRound].slice(-totalRounds(room)).filter(correct).length;
  }

  // "ha" and "ha" are dupes, as are "gold" and "golden", but not "hahahaha" and "hah".
  function dupes(clue1, clue2) {
    if (clue1 == clue2) {
      return true;
    }
    return clue1.length >= 3 && clue2.length >= 3 && (clue1.includes(clue2) || clue2.includes(clue1));
  }

  // Return whether the candidate is a dupe of any of the existing clues.
  function anyDupes(clues, candidate) {
    return clues.some(c => dupes(c, candidate));
  }

  function dedupe(clues, showCollisions = true) {
    const cluesToPlayers = {};
    for (const [player, clue] of Object.entries(clues)) {
      let foundDupe = false;
      for (const existingClue of Object.keys(cluesToPlayers)) {
        // If an existing dupe is found, join the strings into the new clue
        if (anyDupes(existingClue.split(' / '), clue)) {
          foundDupe = true;
          cluesToPlayers[existingClue].push(player);
          cluesToPlayers[existingClue + ' / ' + clue] = cluesToPlayers[existingClue];
          delete cluesToPlayers[existingClue];
          break;
        }
      }
      // Otherwise, create a new array for this clue.
      if (!foundDupe) {
        cluesToPlayers[clue] = [player];
      }
    }
    const deduped = Object.entries(cluesToPlayers)
      .filter(([clue, cluers]) => cluers.length == 1)
      .map(([clue, cluers]) => `${cluers[0]} - ${clue}`);
    const conflicts = Object.entries(cluesToPlayers)
      .filter(([clue, cluers]) => cluers.length > 1)
      .map(([clue, cluers]) => cluers.join(' & ') + (showCollisions ? ` - ${clue}` : ''));
    let result = showCollisions ? '' : '(Uh, good luck.)';
    if (deduped.length > 0) {
      result = `${deduped.join('\n')}`
    }
    if (conflicts.length > 0) {
      result += `\n\nCollisions:\n${conflicts.join('\n')}`;
    }
    return result;
  }

  function nextGuesser(lastGuesser, players) {
    const nextIndex = (players.indexOf(lastGuesser) + 1 + players.length) % players.length;
    return players[nextIndex];
  }

  function randomWord(category='nouns', customWords='') {
    const custom = customWords.split(/\s/);
    const categories = { nouns, compounds, verbs, adjectives, custom };
    const words = categories[category];
    return words[Math.floor(Math.random() * words.length)];
  }

  function nextWord(history, category='nouns', customWords='') {
    let word;
    let loops = 0;
    do {
      loops++;
      if (loops > 10000) {
        return "You're out of custom words..."
      }
      // TODO: consider generating a stable next word using seeded RNG.
      word = randomWord(category, customWords);
    } while (history.map(round => round.word).includes(word));
    return word;
  }

  function nextCategory(categories) {
    const enabled = Object.keys(categories).filter(c => categories[c]);
    return enabled[Math.floor(Math.random() * enabled.length)];
  }
</script>